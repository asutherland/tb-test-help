// Provide an idea of what your mozilla loop is up to.
// asutherland@asutherland.org

// Args:
// 1: Path to libxpcom_core.so
//
// (Need to figure out how to just take the base-path and manipulate... although
// our source line offests suggest a preprocessing pass may be required
// anyways.)

// Example output (when processed with addrsymfilt.py):
//====================                                             ms    #
//----- Event Loop:
//  nsTimerEvent                                                   76   18
//  nsHttpConnectionMgr::nsConnEvent                                0    1
//----- Timers:
//  nsGlobalWindow::TimerCallback(...)                             74   10
//  nsIdleService::IdleTimerCallback(...)                           0    4
//  nsHttpHandler                                                   0    1
//  nsUITimerCallback                                               0    2
//  nsExpirationTracker<gfxTextRun, 3u>::TimerCallback(...)         0    1


// line offests are currently against mozilla-1.9.2

////////////////////////////////////////////////////////////////////////////////
//// Event Loop Duration Stuff

global event_thread_depth;
global event_entry_times;
global event_addresses;

global event_duration;
global event_count;

//!! Wrap-before
probe process(@1).statement("nsThread::ProcessNextEvent@nsThread.cpp:520") {
  ctx = tid();
  depth = event_thread_depth[ctx]++;
  event_addresses[ctx, depth] = 0;
}

//!! Execution
// We need to use a line-specific statement because event is never a member
//  variable.
probe process(@1).statement("nsThread::ProcessNextEvent@nsThread.cpp:527") {
  // $event->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  eventAddr = @cast(&$event, "be_a_pptr", "<be_a_ptr.h>")[0];

  ctx = tid();
  depth = event_thread_depth[ctx] - 1;
  time = gettimeofday_us();
  event_entry_times[ctx, depth] = time;
  event_addresses[ctx, depth] = eventAddr;
}

//!! Wrap-after as exit
probe process(@1).statement("nsThread::ProcessNextEvent@nsThread.cpp:535") {
  ctx = tid();
  depth = --event_thread_depth[ctx];
  eventAddr = event_addresses[ctx, depth];

  if (eventAddr) {
    time = gettimeofday_us();
    runtime = time - event_entry_times[ctx, depth];

    event_duration[eventAddr] += runtime;
    event_count[eventAddr]++;
  }
}


////////////////////////////////////////////////////////////////////////////////
//// Timer Duration Stuff

global timer_duration;
global timer_count;

global timer_entry_times;
global timer_thread_depth;

global timer_addresses;

//!! Entry
probe process(@1).statement("nsTimerImpl::Fire@nsTimerImpl.cpp:419")
{
  if ($callbackType == 2)
    timerAddr = $callback->c;
  else
    timerAddr = @cast(&$callback, "be_a_pptr", "<be_a_ptr.h>")[0];

  ctx = tid();
  depth = timer_thread_depth[ctx]++;
  time = gettimeofday_us();
  timer_entry_times[ctx, depth] = time;
  timer_addresses[ctx, depth] = timerAddr;
}

//!! Exit
probe process(@1).statement("nsTimerImpl::Fire@nsTimerImpl.cpp:454")
{
  ctx = tid();
  depth = --timer_thread_depth[ctx];
  time = gettimeofday_us();

  runtime = time - timer_entry_times[ctx, depth];

  timerAddr = timer_addresses[ctx, depth];
  
  timer_duration[timerAddr] += runtime;
  timer_count[timerAddr]++;
}

// nsProxyObjectCallInfo::Run

/* ==== Reporting ==== */
probe timer.s(10) {
  printf("\n====================                                             ms    #\n----- Event Loop:\n");
  foreach (eventAddr in event_duration-) {
    printf("  :!vt,59:%x %5d %4d\n", eventAddr,
           event_duration[eventAddr] / 1000, event_count[eventAddr]);
  }
  delete event_duration;
  delete event_count;

  printf("----- Timers:\n");
  foreach (timerAddr in timer_duration-) {
    printf("  :!vt,59:%x %5d %4d\n", timerAddr,
           timer_duration[timerAddr] / 1000, timer_count[timerAddr]);
  }
  delete timer_duration;
  delete timer_count;
}
