/* *****************************************************************************
 * OVERVIEW
 *
 * Generate GWT Speed Tracer-ish JSON output from the mozilla-1.9.2 platform.
 *
 * The end-form data dump format documentation required by Speed Tracer is here:
 * http://code.google.com/webtoolkit/speedtracer/data-dump-format.html
 *
 * General Speed Tracer documentation is here:
 * http://code.google.com/webtoolkit/speedtracer/
 *
 * invoke like so:
 *  sudo stap -g -DMAXSTRINGLEN=1024 moz-alloc-track.st /path/to/libmozjs.so
 *
 * then post-process like so:
 *
 * The key stap arguments mean:
 * - "-g" allows us to use embedded C code
 * - "-DMAXSTRINGLEN=1024" allows us to process really long strings albeit with
 *    some potential memory bloat.
 * - "-b" enables bulk mode transmission of data which means greatly reduced
 *    userspace crossings (I think... we'll see! :).
 * - "-sNUM" NUM megabyte per-cpu buffers for bulk transfer
 * - "-o FILE" names bulk transfer files FILE_cpu.
 *
 * This file is made available under the GPLv3 license; its outputs are not
 *  covered by the license; they are yours for the taking!
 *
 * Copyright 2010, the Mozilla Foundation.
 * Andrew Sutherland <asutherland@asutherland.org>
 * Mozilla Messaging, Inc.
 *
 * *****************************************************************************
 * IMPLEMENTATION DETAILS
 *
 * We are unable to emit an immediately usable speed tracer trace because the
 *  official trace format is tree-structured with nested child records.  Even
 *  if we ignored the semantic ramifications of nested event loops, we still
 *  have multiple threads doing things and we do care what all threads get up
 *  to.  If we had richer data structures available to us we could deal with the
 *  nesting and what not by only flushing top-level events when they are
 *  completed, but we don't have that.  Which is just as well because we'd still
 *  potentially need to set processor affinities.
 * 
 * So what we do is emit what is basically a flattened/augmented dialect of the
 *  speed tracer format that allows us to fairly easily reconstruct things into
 *  the official representation.  This has the positive side-effect of letting
 *  us use the bulk mode of operation for theoretically improved performance.
 *
 * We emit the following additional attributes for each event:
 * - tid: The thread id that this event occurred on.
 * - depth: The event depth for the current thread.
 * - tseq: The sequence of this event on this thread.  Parents have thread
 *    sequence numbers preceding their children.  We use this to provide
 *    certifiably correct reconstruction in the face of multiple threads on
 *    more than 2 cores given per-cpu buffers.  The nanosec timestamp values
 *    we also include may be more than sufficient for this and we may drop this
 *    once all the bugs are worked out of reconstruction.  (We only need this
 *    if threads can migrate across cores at a higher rate than the timing
 *    interval's maximum resolution.)
 *
 * We encode the following attributes differently:
 * - time: We store the number of nanoseconds since the start of the session
 *    rather than the number of milliseconds.  We've got'em, why not use'em?
 * - duration: We store the duration in nanoseconds instead of milliseconds.
 *
 * Events which have children are emitted after their children by virtue of how
 *  control flow works in this, our causal universe.
 *
 * Reconstruction amounts to postfix traversal.  We see every event's children
 *  before we see the event.  Imagine the following call-stack where time is
 *  flowing down, the indentation indicates call stack depth and the letters
 *  indicate each invocation and the meta-data off to the right:
 *   a     tseq: 0  depth: 0
 *    b    tseq: 1  depth: 1
 *     c   tseq: 2  depth: 2
 *     d   tseq: 3  depth: 2
 *    e    tseq: 4  depth: 1
 *     f   tseq: 5  depth: 2
 * This represents a calling two functions with the first call itself making two
 *  function calls and the second just one.  The event sequence produced by our
 *  probes would be: c, d, b, f, e, a.  Our logic goes like so:
 * - We see 'c' and have no current state.  We stick it in a list and tag it
 *    with depth 2.
 * - We see 'd'; it has the same depth as our current list, so we just stick it
 *    in there.
 * - We see 'b'; it has a depth less than our current list so we take the
 *    contents of the list and add them as children to 'b'.  We make a new list
 *    with 'b' in it and tag it with depth 1.
 * - We see 'f'; it has greater depth than our active 'b' list so we push a new
 *    list onto our stack with 'f' in it tagged with depth 2.
 * - We see 'e'; it has depth less than 'f' so we pop the list adding 'f' as a
 *    child.  The top list that holds 'b' has the same depth (1), so we add 'e'
 *    to that list.
 * - We see 'a'; it has depth less than the 'b' and 'e' list so we pop that list
 *    and add them as its children.
 *    
 *  
 *
 * *****************************************************************************
 * PROTOCOL NOTES
 *
 * - "sequence" attributes only appear to exist for top-level records and are
 *    present in child records (per mock logs).
 * - "usedHeapSize" and "totalHeapSize" are not used in the mock logs and it's
 *    not clear how the UI would surface them anyways?  I'll look into this when
 *    it comes time to attribute memory usage.
 */
// -b implies an -o option...
//@@stapargs:-g,-DMAXSTRINGLEN=1024,-b,-s2
//@@postprocess:stpostproc

////////////////////////////////////////////////////////////////////////////////
//////// Shared State

/** maps [thread] to current thread depth */
global t_depth;
/** maps [thread, depth] to start time */
global td_start;
/** maps [thread, depth] to pre-fetched data */
global td_pre_data;

global dawn_of_time;

probe begin {
  dawn_of_time = gettimeofday_ns();
}

function track_enter(eventCode, pre_data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx]++;

  td_start[ctx, depth] = now;
  td_pre_data[ctx, depth] = pre_data;

  //printf("enter: %d @ %d ... %s\n", eventCode, depth, pre_data);
}

function track_leave(eventCode, data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = --t_depth[ctx];

  start = td_start[ctx, depth];
  pre_data = td_pre_data[ctx, depth];

  duration = now - start;

  //printf("exit: %d @ %d ... %s\n", eventCode, depth, data);

  printf("{\"tid\":%d,\"depth\":%d,\"type\":%d,"
         "\"time\":%d,\"duration\":%d,\"data\":{%s%s}}\n",
         ctx, depth, eventCode,
         start - dawn_of_time, duration, pre_data, data);
}


////////////////////////////////////////////////////////////////////////////////
//////// Browser Timeline Events

////////////////////////////////////////////////////////////////////////////////
//// DOM_EVENT : 0

////////////////////////////////////////////////////////////////////////////////
//// LAYOUT : 1

probe process(@@lib:bin/components/libgklayout.so).function("PresShell::DoReflow") {
  track_enter(1, "");
}

// returns false when interrupted, true when completed
probe process(@@lib:bin/components/libgklayout.so).function("PresShell::DoReflow").return {
  track_leave(1, "");
}


////////////////////////////////////////////////////////////////////////////////
//// RECALC_STYLE : 2

// These are also somewhat related to PresShell::FlushPendingNotifications, but
//  the hope is that we catch all that through specific coverage of its
//  children.

probe process(@@lib:bin/components/libgklayout.so).function("nsCSSFrameConstructor::ProcessPendingRestyles") {
  track_enter(2, "");
}

probe process(@@lib:bin/components/libgklayout.so).function("nsCSSFrameConstructor::ProcessPendingRestyles").return {
  track_leave(2, "");
}

////////////////////////////////////////////////////////////////////////////////
//// PAINT : 3

////////////////////////////////////////////////////////////////////////////////
//// PARSE_HTML : 4

////////////////////////////////////////////////////////////////////////////////
//// TIMER_INSTALLED : 5

////////////////////////////////////////////////////////////////////////////////
//// TIMER_CLEARED : 6

////////////////////////////////////////////////////////////////////////////////
//// TIMER_FIRED : 7

// === Global Window setTimeout/setInterval timers
// we just note the JS boundary crossing here

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  if ($scriptObject)
    track_enter(15, ""); // but we're calling into JS here...
}

// the eval case
//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:PRBool is_undefined;
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  data = sprintf("\"scriptName\":\"%s\",\"scriptLine\":%d",
                 user_string($filename), $lineNo);
  track_enter(15, data);
}

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:handler = nsnull; // drop reference before dropping timeout refs.
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  scriptObj = $scriptObject;
  // the non-scriptObj case is handled by the preceding probe
  if (scriptObj) {
    data = script_info_from_jsfunobj(scriptObj);
    track_leave(15, data);
  }
  else {
    track_leave(15, "");
  }
}

// === nsITimer (convertible to Global Window)

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_enter(7, "");

  // fake an entry to say where we are going, native-like.
  if ($callbackType == 2)
    timerAddr = $callback->c;
  else
    timerAddr = @cast(&$callback, "be_a_pptr", "<be_a_ptr.h>")[0];

  data = sprintf("\"scriptName\":\":!vt:%x\",\"scriptLine\":0", timerAddr);
  track_enter(15, data);
}

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
//@@lineseek:mFiring = PR_FALSE;
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_leave(15, "");
  track_leave(7, "");
}


////////////////////////////////////////////////////////////////////////////////
//// XHR_READY_STATE_CHANGE : 8

////////////////////////////////////////////////////////////////////////////////
//// XHR_LOAD : 9

////////////////////////////////////////////////////////////////////////////////
//// EVAL_SCRIPT : 10

////////////////////////////////////////////////////////////////////////////////
//// LOG_MESSAGE : 11

// These come from console.markTimeline(message) calls in Chrome.  We could
//  accomplish the same thing if we exposed a native or found an existing native
//  we could co-opt.  dump is co-optable given that its rate of invocation is
//  low enough that we could perform a simple string formatting rule to
//  determine what wants actually wants to get logged.

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_START : 12

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_RESPONSE: 13

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_FINISH : 14

////////////////////////////////////////////////////////////////////////////////
//// JAVASCRIPT_CALLBACK : 15

// === Event Loop (abuse of this event)

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  // $event->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  if ($event->mRawPtr)
    eventAddr = @cast(&$event, "be_a_pptr", "<be_a_ptr.h>")[0];
  else
    eventAddr = 0;

  data = sprintf("\"scriptName\":\":!vt:%x\",\"scriptLine\":0", eventAddr);
  track_enter(15, data);
}

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
//@@lineseek:--mRunningEvent;
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_leave(15, "");
}


// === XPConnect crossing into JS (abuse of this event)

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = js_Invoke(cx, argc, stackbase, 0);
probe process(@@lib:bin/components/libxpconnect.so).statement(@@statement:ref) {
  track_enter(15, "");
}

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = js_Invoke(cx, argc, stackbase, 0);
//@@lineseek:result = *stackbase;
probe process(@@lib:bin/components/libxpconnect.so).statement(@@statement:ref) {
  data = script_info_from_jsfunobj($fval);
  track_leave(15, data);
}

////////////////////////////////////////////////////////////////////////////////
//// RESOURCE_DATA_RECEIVED : 16

////////////////////////////////////////////////////////////////////////////////
//// GC_EVENT : 17

probe process(@@lib:lib/libmozjs.so).function("js_GC") {
  track_enter(17, "");
}

probe process(@@lib:lib/libmozjs.so).function("js_GC").return {
  track_leave(17, "");
}


////////////////////////////////////////////////////////////////////////////////
//// MARK_DOM_CONTENT : 18

////////////////////////////////////////////////////////////////////////////////
//// MARK_LOAD_EVENT : 19

////////////////////////////////////////////////////////////////////////////////
//////// Speed Tracer Events

////////////////////////////////////////////////////////////////////////////////
//// TAB_CHANGED : 0x7f ff ff fe

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_UPDATE : 0x7f ff ff fd

////////////////////////////////////////////////////////////////////////////////
//// PROFILE_DATA : 0x7f ff ff fc

// The documentation really cops out here (but avoids calling attention to it :)


////////////////////////////////////////////////////////////////////////////////
//////// Common JS extraction stuff

global jsfun_cache_func_name;
global jsfun_cache_filename;
global jsfun_cache_line;

function jsval_to_string(jsval) {
  if (jsval == 0) {
    return "null";
  }
  // integer!
  else if (jsval&0x1) {
    return sprintf("%d", jsval >> 1)
  }

  tag = jsval & 0x7;
  // double
  if (tag == 0x2) {
    //return sprintf("%f",
    //               @cast(jsval & ~0x7, "jsdouble", @@lib:lib/libmozjs.so));
    return "<double>";
  }
  // string
  else if (tag == 0x4) {
    jsval = jsval & ~0x7;
    len = @cast(jsval, "JSString", @@lib:lib/libmozjs.so)->mLength & 0x1ff;
    cp = @cast(jsval, "JSString", @@lib:lib/libmozjs.so)->mChars;

    return user_u16_string(cp, len);
  }
  // special
  else if (tag == 0x6) {
    thing = jsval >> 3;
    if (thing == 0)
      return "false";
    else if (thing == 1)
      return "true";
    else if (thing == 2)
      return "undefined";
    else
      return "unknown special";
  }
  return sprintf("<??? %p>", jsval);
}

function script_info_from_jsfunobj(jsfunobj) {
  if (jsfunobj) {
    jsfun = @cast(jsfunobj, "JSObject", @@lib:lib/libmozjs.so)->fslots[2];
  }
  else {
    jsfun = 0;
  }
  return script_info_from_jsfun(jsfun);
}

function script_info_from_jsfun(jsfun) {
  if (jsfun_cache_line[jsfun] == 0) {
    if (!jsfun) {
      atom = 0;
      jsfun_cache_func_name[jsfun] = "<no func>";
    }
    else {
      atom = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->atom;
    }

    jsfun_cache_func_name[jsfun] = jsval_to_string(atom);

    funflags = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->flags;

    // interpreted?
    if ((funflags & 0xc000) >= 0x4000) {
      script = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->u->i->script;
      if (script) {
        jsfun_cache_filename[jsfun] =
          basename(user_string(@cast(script, "JSScript",
                                     @@lib:lib/libmozjs.so)->filename));
        jsfun_cache_line[jsfun] = @cast(script, "JSScript",
                                        @@lib:lib/libmozjs.so)->lineno;
      }
      else {
        jsfun_cache_filename[jsfun] = "<no script>";
        jsfun_cache_line[jsfun] = 1;
      }
    }
    else { // native
      // XXX emit pointer with translation decorations.
      jsfun_cache_filename[jsfun] = "<native>";
      jsfun_cache_line[jsfun] = 1;
    }
  }
  return sprintf("\"scriptName\":\"%s\","
                 "\"scriptLine\":%d,"
                 "\"functionName\":\"%s\"",
                 jsfun_cache_filename[jsfun],
                 jsfun_cache_line[jsfun],
                 jsfun_cache_func_name[jsfun]);
}


/**
 * Copy a u16 string truncating to ASCII.
 */
function user_u16_string:string (addr: long, nchars: long) %{ /* pure */ /* unprivileged */
  // we need space for the u16...
  int64_t len = clamp_t(int64_t, THIS->nchars*2, 2, MAXSTRINGLEN);
  // needs to be even
  if (len%2)
    len--;
  assert_is_myproc();
  if (_stp_copy_from_user(THIS->__retvalue,
                          (char __user *) (uintptr_t) THIS->addr,
                          len) == 0) {
    // now transform down...
    char *ocp = THIS->__retvalue;
    uint16_t *icp = (uint16_t *)THIS->__retvalue;
    uint16_t *termp = (uint16_t *)&THIS->__retvalue[len];
    for (;icp < termp; icp++) {
      if (*icp >= 0x80)
        *ocp++ = 'X';
      else
        *ocp++ = (char)*icp;
    }
    *ocp = '\0';
  }
  else {
    strlcpy(THIS->__retvalue, "<problem>", MAXSTRINGLEN);
  }
%}

function basename:string (str: string) %{ /* pure */ /* unprivileged */
  char *cp;
  char *last_slash = THIS->str;
  for (cp = THIS->str; *cp != '\0'; cp++) {
    if (*cp == '/')
      last_slash = cp+1;
  }

  strlcpy(THIS->__retvalue, last_slash, strlen(last_slash) + 1);
%}
