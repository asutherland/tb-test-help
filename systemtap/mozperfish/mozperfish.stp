/* *****************************************************************************
 * OVERVIEW
 *
 * Generate performance (time + memory usage) JSON output from the mozilla-1.9.2
 *  platform.  This used to be biased to produce GWT Speed Tracer output but
 *  that was abandoned when it became clear that our purposes were not aligned
 *  with its purpose.  I'll try and keep things aligned until there are reasons
 *  to not be aligned.
 *
 * For as long as we are sorta Speed Tracer aligned, the following links may be
 *  useful:
 *
 * The end-form data dump format documentation required by Speed Tracer is here:
 * http://code.google.com/webtoolkit/speedtracer/data-dump-format.html
 *
 * General Speed Tracer documentation is here:
 * http://code.google.com/webtoolkit/speedtracer/
 *
 * The key stap arguments mean:
 *
 * This file is made available under the standard MPL1.1/GPL2/LGPL2.1 license.
 *  Its output are not covered by the license; they are yours for the taking!
 *
 * Copyright 2010, the Mozilla Foundation.
 * Andrew Sutherland <asutherland@asutherland.org>
 * Mozilla Messaging, Inc.
 *
 * *****************************************************************************
 * IMPLEMENTATION DETAILS
 *
 * We are unable to emit an immediately usable speed tracer trace because the
 *  official trace format is tree-structured with nested child records.  Even
 *  if we ignored the semantic ramifications of nested event loops, we still
 *  have multiple threads doing things and we do care what all threads get up
 *  to.  If we had richer data structures available to us we could deal with the
 *  nesting and what not by only flushing top-level events when they are
 *  completed, but we don't have that.  Which is just as well because we'd still
 *  potentially need to set processor affinities.
 * 
 * So what we do is emit what is basically a flattened/augmented dialect of the
 *  speed tracer format that allows us to fairly easily reconstruct things into
 *  the official representation.  This has the positive side-effect of letting
 *  us use the bulk mode of operation for theoretically improved performance.
 *
 * We emit the following additional attributes for each event:
 * - tid: The thread id that this event occurred on.
 * - depth: The event depth for the current thread.
 * - tseq: The sequence of this event on this thread.  Parents have thread
 *    sequence numbers preceding their children.  We use this to provide
 *    certifiably correct reconstruction in the face of multiple threads on
 *    more than 2 cores given per-cpu buffers.  The nanosec timestamp values
 *    we also include may be more than sufficient for this and we may drop this
 *    once all the bugs are worked out of reconstruction.  (We only need this
 *    if threads can migrate across cores at a higher rate than the timing
 *    interval's maximum resolution.)
 *
 * We encode the following attributes differently:
 * - time: We store the number of nanoseconds since the start of the session
 *    rather than the number of milliseconds.  We've got'em, why not use'em?
 * - duration: We store the duration in nanoseconds instead of milliseconds.
 *
 * Events which have children are emitted after their children by virtue of how
 *  control flow works in this, our causal universe.
 *
 * Reconstruction amounts to postfix traversal.  We see every event's children
 *  before we see the event.  Imagine the following call-stack where time is
 *  flowing down, the indentation indicates call stack depth and the letters
 *  indicate each invocation and the meta-data off to the right:
 *   a     tseq: 0  depth: 0
 *    b    tseq: 1  depth: 1
 *     c   tseq: 2  depth: 2
 *     d   tseq: 3  depth: 2
 *    e    tseq: 4  depth: 1
 *     f   tseq: 5  depth: 2
 * This represents a calling two functions with the first call itself making two
 *  function calls and the second just one.  The event sequence produced by our
 *  probes would be: c, d, b, f, e, a.  Our logic goes like so:
 * - We see 'c' and have no current state.  We stick it in a list and tag it
 *    with depth 2.
 * - We see 'd'; it has the same depth as our current list, so we just stick it
 *    in there.
 * - We see 'b'; it has a depth less than our current list so we take the
 *    contents of the list and add them as children to 'b'.  We make a new list
 *    with 'b' in it and tag it with depth 1.
 * - We see 'f'; it has greater depth than our active 'b' list so we push a new
 *    list onto our stack with 'f' in it tagged with depth 2.
 * - We see 'e'; it has depth less than 'f' so we pop the list adding 'f' as a
 *    child.  The top list that holds 'b' has the same depth (1), so we add 'e'
 *    to that list.
 * - We see 'a'; it has depth less than the 'b' and 'e' list so we pop that list
 *    and add them as its children.
 *    
 *  
 *
 * *****************************************************************************
 * PROTOCOL NOTES
 *
 * - "sequence" attributes only appear to exist for top-level records and are
 *    present in child records (per mock logs).
 * - "usedHeapSize" and "totalHeapSize" are not used in the mock logs and it's
 *    not clear how the UI would surface them anyways?  I'll look into this when
 *    it comes time to attribute memory usage.
 */
//@@stapargs:-g,-DMAXSTRINGLEN=1024,-b,-s2
// "-g" allows us to use embedded C code
// "-DMAXSTRINGLEN=1024" allows us to process really long strings albeit with
//    some potential memory bloat.
// "-b" enables bulk mode transmission of data which means greatly reduced
//    userspace crossings (I think... we'll see! :).  Our driver automatically
//    adds an "-o" option.
// "-sNUM" NUM megabyte per-cpu buffers for bulk transfer

//@@postprocess:perfishpostproc

////////////////////////////////////////////////////////////////////////////////
//////// Shared State

/** maps [thread] to current thread depth */
global t_depth;
/** maps [thread, depth] to start time */
global td_start;
/** maps [thread, depth] to pre-fetched data */
global td_pre_data;

global dawn_of_time;

probe begin {
  dawn_of_time = gettimeofday_ns();
}

function track_enter(eventCode, pre_data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx]++;

  // if we are depth 0, handle inter-event stuff...
  if ((depth == 0) && td_any_alloc[ctx, -1]) {
    printf("{\"tid\":%d,\"depth\":null,\"type\":null,"
           "\"mem\":{",
           ctx);
    mem_stats_data_string(ctx, -1);
    printf("}}\n");
    td_any_alloc[ctx, -1] = 0;
  }
  // clear the memory tracking for this context/depth
  td_any_alloc[ctx, depth] = 0;

  td_start[ctx, depth] = now;
  td_pre_data[ctx, depth] = pre_data;

  //printf("enter: %d @ %d ... %s\n", eventCode, depth, pre_data);
}

function track_leave(eventCode, data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = --t_depth[ctx];

  // fix-up and bail if we were just catching the tail end of an event
  if (depth < 0) {
    t_depth[ctx] = 0;
  }
  else {
    start = td_start[ctx, depth];
    pre_data = td_pre_data[ctx, depth];

    duration = now - start;

    //printf("exit: %d @ %d ... %s\n", eventCode, depth, data);

    printf("{\"tid\":%d,\"depth\":%d,\"type\":%d,"
           "\"time\":%d,\"duration\":%d,\"data\":{%s%s},\"mem\":{",
           ctx, depth, eventCode,
           start - dawn_of_time, duration, pre_data, data);
    if (td_any_alloc[ctx, depth])
      mem_stats_data_string(ctx, depth);
    printf("}}\n");
  }
}


////////////////////////////////////////////////////////////////////////////////
//////// Memory Allocation Stuff

/*
 * The goals for tracking memory allocation are:
 * - Attribute memory activity to the containing event (or gaps when there is
 *    no active event.)
 * - Track general statistics for all (de)allocations; we want to know how
 *    many allocations occurred, how many frees occurred, and how many bytes
 *    were involved for each.  We want to be able to observe when death by
 *    paper cuts is happening for small and medium allocations.  For huge
 *    allocations we will be tracking their full life cycles, but it's nice to
 *    have the uniform presentation here too (and perhaps be able to turn off
 *    life-cycle.)
 * - Generate explicit events for all huge allocations (1 MiB and larger per
 *    jemalloc and us) so that we can directly track their life-cycles.
 * - reallocations are only really interesting 
 *
 * Here's the memory allocation scam:
 *
 *
 *
 * We maintain counters for count and total allocation size for a few different
 *  types of allocations for smaller allocations.  For larger allocations we
 *  emit their own JSON records so we can explicitly trace their life-cycle.
 *
 * kernel:
 * 0x0: mmap/munmap
 *
 * jemalloc:
 * 0x10: small
 * 0x11: large
 * 0x12: huge
 *
 * JS:
 * 0x40: object
 * 0x41: string
 * 0x42: function
 * 0x43: xml
 */

/** mapps [thread, depth] to whether any alloc happened */
global td_any_alloc;
/** maps [thread, depth, kind] to alloc count */
global tdk_mem_alloc_count;
/** maps [thread, depth, kind] to alloc byte tally */
global tdk_mem_alloc_bytes;
/** maps [thread, depth, kind] to realloc count */
global tdk_mem_realloc_count;
/** maps [thread, depth, kind] to realloc growth bytes */
global tdk_mem_realloc_bytes_growth;
/** maps [thread, depth, kind] to realloc shrink bytes */
global tdk_mem_realloc_bytes_shrink;
/** maps [thread, depth, kind] to free count */
global tdk_mem_free_count;
/** maps [thread, depth, kind] to free byte tally */
global tdk_mem_free_bytes;

function mem_stats_data_string(ctx, depth_idx) {
  // alloc
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x0]) {
    printf("\"kernel_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x0],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x0]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x0] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x0] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x10]) {
    printf("\"je_small_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x10],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x10]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x10] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x10] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x11]) {
    printf("\"je_large_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x11],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x11]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x11] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x11] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x12]) {
    printf("\"je_huge_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x12],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x12]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x12] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x12] = 0;
  }

  // realloc
  if (tdk_mem_realloc_count[ctx, depth_idx, 0x1]) {
    printf("\"je_realloc\":[%d,%d,%d],",
           tdk_mem_realloc_count[ctx, depth_idx, 0x1],
           tdk_mem_realloc_bytes_growth[ctx, depth_idx, 0x1],
           tdk_mem_realloc_bytes_shrink[ctx, depth_idx, 0x1]);
    tdk_mem_realloc_count[ctx, depth_idx, 0x1] = 0;
    tdk_mem_realloc_bytes_growth[ctx, depth_idx, 0x1] = 0;
    tdk_mem_realloc_bytes_shrink[ctx, depth_idx, 0x1] = 0;
  }
  
  // free
  if (tdk_mem_free_count[ctx, depth_idx, 0x0]) {
    printf("\"kernel_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x0],
           tdk_mem_free_bytes[ctx, depth_idx, 0x0]);
    tdk_mem_free_count[ctx, depth_idx, 0x0] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x0] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x10]) {
    printf("\"je_small_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x10],
           tdk_mem_free_bytes[ctx, depth_idx, 0x10]);
    tdk_mem_free_count[ctx, depth_idx, 0x10] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x10] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x11]) {
    printf("\"je_large_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x11],
           tdk_mem_free_bytes[ctx, depth_idx, 0x11]);
    tdk_mem_free_count[ctx, depth_idx, 0x11] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x11] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x12]) {
    printf("\"je_huge_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x12],
           tdk_mem_free_bytes[ctx, depth_idx, 0x12]);
    tdk_mem_free_count[ctx, depth_idx, 0x12] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x12] = 0;
  }
}

function mem_stats_track_alloc(kind, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_alloc_count[ctx, depth_idx, kind]++;
  tdk_mem_alloc_bytes[ctx, depth_idx, kind] += size;
}

function mem_stats_track_realloc(kind, oldsize, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;
  delta = size - oldsize;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_realloc_count[ctx, depth_idx, kind]++;
  if (delta > 0)
    tdk_mem_realloc_bytes_growth[ctx, depth_idx, kind] += delta;
  else
    tdk_mem_realloc_bytes_shrink[ctx, depth_idx, kind] += delta;
}

function mem_stats_track_free(kind, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_free_count[ctx, depth_idx, kind]++;
  tdk_mem_free_bytes[ctx, depth_idx, kind] += size;
}

function mem_life_cycle_alloc(kind, ptr, size) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"alloc\","
         "\"time\":%d,\"data\":{\"source\":%d,\"ptr\":%d,\"size\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, ptr, size);
}

function mem_life_cycle_realloc(kind, oldptr, newptr, oldsize, newsize) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"realloc\","
         "\"time\":%d,\"data\":{\"source\":%d,\"oldptr\":%d,\"newptr\":%d,"
         "\"oldsize\":%d,\"newsize\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, oldptr, newptr, oldsize, newsize);
}

function mem_life_cycle_free(kind, ptr, size) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"free\","
         "\"time\":%d,\"data\":{\"source\":%d,\"ptr\":%d,\"size\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, ptr, size);
}


////////////////////////////////////////////////////////////////////////////////
//// kernel

// too expensive!!
/*
// the vm.mmap point wants do_mmap/do_mmap2 which we cannot have...
probe kernel.function("do_mmap_pgoff") {
  if (pid() != target())
    next;

  address = $addr;
  length = $len;
  mem_stats_track_alloc(0x0, length);
  mem_life_cycle_alloc(0x0, address, length);
}

probe vm.munmap {
  if (pid() != target())
    next;

  mem_stats_track_free(0x0, length);
  mem_life_cycle_free(0x0, address, length);
}
*/

////////////////////////////////////////////////////////////////////////////////
//// jemalloc

// jemalloc gets linked into thunderbird-bin proper
// the following are defined in terms of other exposed operations:
// - posix_memalign in terms of memalign
// - valign in terms of memalign

// arena_malloc_small
// arena_malloc_large
// huge_malloc

// ???
// arena_palloc, huge_palloc

// arena_ralloc
// huge_ralloc

// arena_dalloc_small
// arena_dalloc_large
// huge_dalloc



//// alloc

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_malloc_small
//@@lineseek:arena_malloc_small(arena_t *arena, size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_stats_track_alloc(0x10, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_malloc_large
//@@lineseek:arena_malloc_large(arena_t *arena, size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_stats_track_alloc(0x11, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_malloc
//@@lineseek:huge_malloc(size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  size = $size;
  mem_stats_track_alloc(0x12, size);
  mem_life_cycle_alloc(0x12, $ret, size);
}

//// realloc

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:iralloc
//@@lineseek:iralloc(void *ptr, size_t size)
//@@lineseek:if (size <= arena_maxclass)
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_stats_track_realloc(0x1, $oldsize, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_ralloc
//@@lineseek:huge_ralloc(void *ptr, size_t size, size_t oldsize)
//@@lineseek:if (ret == NULL)
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_life_cycle_realloc(0x12, $ptr, $ret, $oldsize, $size);
}


//// free

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_dalloc_small
//@@lineseek:arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
//@@lineseek:arena_run_reg_dalloc(run, bin, ptr, size);
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_stats_track_free(0x10, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_dalloc_large
//@@lineseek:arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
// MALLOC_STATS is always defined for us, so this line will always be available
//@@lineseek:arena->stats.allocated_large -= size;
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  mem_stats_track_free(0x11, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_dalloc
//@@lineseek:huge_dalloc(void *ptr)
//@@lineseek:extent_tree_ad_remove(&huge, node);
probe process(@@lib:bin/thunderbird-bin).statement(@@statement:ref) {
  size = $node->size;
  mem_stats_track_free(0x12, size);
  mem_life_cycle_free(0x12, $ptr, size);
}


////////////////////////////////////////////////////////////////////////////////
//// JavaScript

/*
 * SpiderMonkey uses arenas.
 */

/*
probe process(@@lib:lib/libmozjs.so).function("NewGCArena") {
}
*/

/*
 * There's a NewGCThing<T> template that we could probably wildcard, but the
 *  apparent use count is low enough it seems worth it to specialize here...
 */

/*
probe process(@@lib:lib/libmozjs.so).function("js_NewGCObject") {
}

probe process(@@lib:lib/libmozjs.so).function("js_NewGCString") {
}

probe process(@@lib:lib/libmozjs.so).function("js_NewGCFunction") {
}

probe process(@@lib:lib/libmozjs.so).function("js_NewGCXML") {
}
*/

////////////////////////////////////////////////////////////////////////////////
//////// Browser Timeline Events

////////////////////////////////////////////////////////////////////////////////
//// DOM_EVENT : 0

////////////////////////////////////////////////////////////////////////////////
//// LAYOUT : 1

probe process(@@lib:bin/components/libgklayout.so).function("PresShell::DoReflow") {
  track_enter(1, "");
}

// returns false when interrupted, true when completed
probe process(@@lib:bin/components/libgklayout.so).function("PresShell::DoReflow").return {
  track_leave(1, "");
}


////////////////////////////////////////////////////////////////////////////////
//// RECALC_STYLE : 2

// These are also somewhat related to PresShell::FlushPendingNotifications, but
//  the hope is that we catch all that through specific coverage of its
//  children.

probe process(@@lib:bin/components/libgklayout.so).function("nsCSSFrameConstructor::ProcessPendingRestyles") {
  track_enter(2, "");
}

probe process(@@lib:bin/components/libgklayout.so).function("nsCSSFrameConstructor::ProcessPendingRestyles").return {
  track_leave(2, "");
}

////////////////////////////////////////////////////////////////////////////////
//// PAINT : 3

probe process(@@lib:bin/components/libgklayout.so).function("PresShell::Paint") {
  data = sprintf("\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d",
                 $aDirtyRegion->mBoundRect->x, $aDirtyRegion->mBoundRect->y,
                 $aDirtyRegion->mBoundRect->width,
                 $aDirtyRegion->mBoundRect->height);
  track_enter(3, data);
}

// returns false when interrupted, true when completed
probe process(@@lib:bin/components/libgklayout.so).function("PresShell::Paint").return {
  track_leave(3, "");
}

////////////////////////////////////////////////////////////////////////////////
//// PARSE_HTML : 4

////////////////////////////////////////////////////////////////////////////////
//// TIMER_INSTALLED : 5

////////////////////////////////////////////////////////////////////////////////
//// TIMER_CLEARED : 6

////////////////////////////////////////////////////////////////////////////////
//// TIMER_FIRED : 7

// === Global Window setTimeout/setInterval timers
// we just note the JS boundary crossing here

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  if ($scriptObject)
    track_enter(15, ""); // but we're calling into JS here...
}

// the eval case
//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:PRBool is_undefined;
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  data = sprintf("\"scriptName\":\"%s\",\"scriptLine\":%d",
                 user_string($filename), $lineNo);
  track_enter(15, data);
}

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:handler = nsnull; // drop reference before dropping timeout refs.
probe process(@@lib:bin/components/libgklayout.so).statement(@@statement:ref) {
  scriptObj = $scriptObject;
  // the non-scriptObj case is handled by the preceding probe
  if (scriptObj) {
    data = script_info_from_jsfunobj(scriptObj);
    track_leave(15, data);
  }
  else {
    track_leave(15, "");
  }
}

// === nsITimer (convertible to Global Window)

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_enter(7, "");

  // fake an entry to say where we are going, native-like.
  if ($callbackType == 2)
    timerAddr = $callback->c;
  else
    timerAddr = @cast(&$callback, "be_a_pptr", "<be_a_ptr.h>")[0];

  data = sprintf("\"scriptName\":\":!vt:%x\",\"scriptLine\":0", timerAddr);
  track_enter(15, data);
}

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
//@@lineseek:mFiring = PR_FALSE;
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_leave(15, "");
  track_leave(7, "");
}


////////////////////////////////////////////////////////////////////////////////
//// XHR_READY_STATE_CHANGE : 8

////////////////////////////////////////////////////////////////////////////////
//// XHR_LOAD : 9

////////////////////////////////////////////////////////////////////////////////
//// EVAL_SCRIPT : 10

////////////////////////////////////////////////////////////////////////////////
//// LOG_MESSAGE : 11

// These come from console.markTimeline(message) calls in Chrome.  We could
//  accomplish the same thing if we exposed a native or found an existing native
//  we could co-opt.  dump is co-optable given that its rate of invocation is
//  low enough that we could perform a simple string formatting rule to
//  determine what wants actually wants to get logged.

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_START : 12

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_RESPONSE: 13

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_FINISH : 14

////////////////////////////////////////////////////////////////////////////////
//// JAVASCRIPT_CALLBACK : 15

////////////////////////////////////////////////////////////////////////////////
//// RESOURCE_DATA_RECEIVED : 16

////////////////////////////////////////////////////////////////////////////////
//// GC_EVENT : 17

probe process(@@lib:lib/libmozjs.so).function("js_GC") {
  track_enter(17, "");
}

probe process(@@lib:lib/libmozjs.so).function("js_GC").return {
  track_leave(17, "");
}


////////////////////////////////////////////////////////////////////////////////
//// MARK_DOM_CONTENT : 18

////////////////////////////////////////////////////////////////////////////////
//// MARK_LOAD_EVENT : 19

////////////////////////////////////////////////////////////////////////////////
//////// Speed Tracer Events

////////////////////////////////////////////////////////////////////////////////
//// TAB_CHANGED : 0x7f ff ff fe

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_UPDATE : 0x7f ff ff fd

////////////////////////////////////////////////////////////////////////////////
//// PROFILE_DATA : 0x7f ff ff fc

// The documentation really cops out here (but avoids calling attention to it :)


////////////////////////////////////////////////////////////////////////////////
//////// Mozilla Made-Up Events

////////////////////////////////////////////////////////////////////////////////
//// Event Loop : 0x1000

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  // $event->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  if ($event->mRawPtr)
    eventAddr = @cast(&$event, "be_a_pptr", "<be_a_ptr.h>")[0];
  else
    eventAddr = 0;

  data = sprintf("\"scriptName\":\":!vt:%x\",\"scriptLine\":0", eventAddr);
  track_enter(0x1000, data);
}

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
//@@lineseek:--mRunningEvent;
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  track_leave(0x1000, "");
}


////////////////////////////////////////////////////////////////////////////////
//// InputStreamReadyEvent : 0x1020

probe process(@@lib:lib/libxpcom_core.so).function("nsInputStreamReadyEvent::Run") {
  // $mCallback->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  callbackAddr = @cast(&$this->mCallback, "be_a_pptr", "<be_a_ptr.h>")[0];

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1020, data);
}

probe process(@@lib:lib/libxpcom_core.so).function("nsInputStreamReadyEvent::Run").return {
  track_leave(0x1020, "");
}


////////////////////////////////////////////////////////////////////////////////
//// nsInputStreamPump::OnInputStreamReady : 0x1021

//@@file:mozilla/netwerk/base/src/nsInputStreamPump.cpp
//@@method:nsInputStreamPump::OnInputStreamReady
//@@lineseek:nsInputStreamPump::OnInputStreamReady(nsIAsyncInputStream *stream)
//@@lineseek:LOG(("nsInputStreamPump::OnInputStreamReady [this=%x]\n", this));
probe process(@@lib:bin/components/libnecko.so).statement(@@statement:ref) {
  rawPtr = $this->mListener->mRawPtr;
  if (rawPtr)
    callbackAddr = @cast(rawPtr, "be_a_pptr", "<be_a_ptr.h>")[0];
  else
    callbackAddr = 0;

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1021, data);
}

probe process(@@lib:bin/components/libnecko.so).function("nsInputStreamPump::OnInputStreamReady").return {
  track_leave(0x1021, "");
}


////////////////////////////////////////////////////////////////////////////////
//// XPConnect -> JS Crossing : 0x1040

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = js_Invoke(cx, argc, stackbase, 0);
probe process(@@lib:bin/components/libxpconnect.so).statement(@@statement:ref) {
  track_enter(0x1040, "");
}

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = js_Invoke(cx, argc, stackbase, 0);
//@@lineseek:result = *stackbase;
probe process(@@lib:bin/components/libxpconnect.so).statement(@@statement:ref) {
  data = script_info_from_jsfunobj($fval);
  track_leave(0x1040, data);
}


////////////////////////////////////////////////////////////////////////////////
//// nsProxyObjectCallInfo : 0x1060

// the prologue logic is not working on this dude, need to move to a statement
//probe process(@1).function("nsProxyObjectCallInfo::Run")
//@@file:mozilla/xpcom/proxy/src/nsProxyEvent.cpp
//@@method:nsProxyObjectCallInfo::Run
//@@lineseek:nsProxyObjectCallInfo::Run()
//@@lineseek:mResult = NS_InvokeByIndex(mOwner->GetProxiedInterface(),
probe process(@@lib:lib/libxpcom_core.so).statement(@@statement:ref) {
  rawPtr = $this->mOwner->mRawPtr->mProxyObject->mRawPtr->mRealObject->mRawPtr;
  // $mCallback->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  callbackAddr = @cast(rawPtr, "be_a_pptr", "<be_a_ptr.h>")[0];

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1060, data);
}

probe process(@@lib:lib/libxpcom_core.so).function("nsProxyObjectCallInfo::Run").return {
  track_leave(0x1060, "");
}


////////////////////////////////////////////////////////////////////////////////
//////// Common JS extraction stuff

global jsfun_cache_func_name;
global jsfun_cache_filename;
global jsfun_cache_line;

function jsval_to_string(jsval) {
  if (jsval == 0) {
    return "null";
  }
  // integer!
  else if (jsval&0x1) {
    return sprintf("%d", jsval >> 1)
  }

  tag = jsval & 0x7;
  // double
  if (tag == 0x2) {
    //return sprintf("%f",
    //               @cast(jsval & ~0x7, "jsdouble", @@lib:lib/libmozjs.so));
    return "<double>";
  }
  // string
  else if (tag == 0x4) {
    jsval = jsval & ~0x7;
    len = @cast(jsval, "JSString", @@lib:lib/libmozjs.so)->mLength & 0x1ff;
    cp = @cast(jsval, "JSString", @@lib:lib/libmozjs.so)->mChars;

    return user_u16_string(cp, len);
  }
  // special
  else if (tag == 0x6) {
    thing = jsval >> 3;
    if (thing == 0)
      return "false";
    else if (thing == 1)
      return "true";
    else if (thing == 2)
      return "undefined";
    else
      return "unknown special";
  }
  return sprintf("<??? %p>", jsval);
}

function script_info_from_jsfunobj(jsfunobj) {
  if (jsfunobj) {
    jsfun = @cast(jsfunobj, "JSObject", @@lib:lib/libmozjs.so)->fslots[2];
  }
  else {
    jsfun = 0;
  }
  return script_info_from_jsfun(jsfun);
}

function script_info_from_jsfun(jsfun) {
  if (jsfun_cache_line[jsfun] == 0) {
    if (!jsfun) {
      atom = 0;
      jsfun_cache_func_name[jsfun] = "<no func>";
    }
    else {
      atom = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->atom;
    }

    jsfun_cache_func_name[jsfun] = jsval_to_string(atom);

    funflags = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->flags;

    // interpreted?
    if ((funflags & 0xc000) >= 0x4000) {
      script = @cast(jsfun, "JSFunction", @@lib:lib/libmozjs.so)->u->i->script;
      if (script) {
        jsfun_cache_filename[jsfun] =
          basename(user_string(@cast(script, "JSScript",
                                     @@lib:lib/libmozjs.so)->filename));
        jsfun_cache_line[jsfun] = @cast(script, "JSScript",
                                        @@lib:lib/libmozjs.so)->lineno;
      }
      else {
        jsfun_cache_filename[jsfun] = "<no script>";
        jsfun_cache_line[jsfun] = 1;
      }
    }
    else { // native
      // XXX emit pointer with translation decorations.
      jsfun_cache_filename[jsfun] = "<native>";
      jsfun_cache_line[jsfun] = 1;
    }
  }
  return sprintf("\"scriptName\":\"%s\","
                 "\"scriptLine\":%d,"
                 "\"functionName\":\"%s\"",
                 jsfun_cache_filename[jsfun],
                 jsfun_cache_line[jsfun],
                 jsfun_cache_func_name[jsfun]);
}


/**
 * Copy a u16 string truncating to ASCII.
 */
function user_u16_string:string (addr: long, nchars: long) %{ /* pure */ /* unprivileged */
  // we need space for the u16...
  int64_t len = clamp_t(int64_t, THIS->nchars*2, 2, MAXSTRINGLEN);
  // needs to be even
  if (len%2)
    len--;
  assert_is_myproc();
  if (_stp_copy_from_user(THIS->__retvalue,
                          (char __user *) (uintptr_t) THIS->addr,
                          len) == 0) {
    // now transform down...
    char *ocp = THIS->__retvalue;
    uint16_t *icp = (uint16_t *)THIS->__retvalue;
    uint16_t *termp = (uint16_t *)&THIS->__retvalue[len];
    for (;icp < termp; icp++) {
      if (*icp >= 0x80)
        *ocp++ = 'X';
      else
        *ocp++ = (char)*icp;
    }
    *ocp = '\0';
  }
  else {
    strlcpy(THIS->__retvalue, "<problem>", MAXSTRINGLEN);
  }
%}

function basename:string (str: string) %{ /* pure */ /* unprivileged */
  char *cp;
  char *last_slash = THIS->str;
  for (cp = THIS->str; *cp != '\0'; cp++) {
    if (*cp == '/')
      last_slash = cp+1;
  }

  strlcpy(THIS->__retvalue, last_slash, strlen(last_slash) + 1);
%}
