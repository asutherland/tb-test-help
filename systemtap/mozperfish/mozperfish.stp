/* *****************************************************************************
 * OVERVIEW
 *
 * Generate performance (time + memory usage) JSON output from the mozilla-2.0
 *  platform.  This used to be biased to produce GWT Speed Tracer output but
 *  that was abandoned when it became clear that our purposes were not aligned
 *  with its purpose.  I'll try and keep things aligned until there are reasons
 *  to not be aligned.
 *
 * For as long as we are sorta Speed Tracer aligned, the following links may be
 *  useful:
 *
 * The end-form data dump format documentation required by Speed Tracer is here:
 * http://code.google.com/webtoolkit/speedtracer/data-dump-format.html
 *
 * General Speed Tracer documentation is here:
 * http://code.google.com/webtoolkit/speedtracer/
 *
 * This file is made available under the standard MPL1.1/GPL2/LGPL2.1 license.
 *  Its output are not covered by the license; they are yours for the taking!
 *
 * Copyright 2010, the Mozilla Foundation.
 * Andrew Sutherland <asutherland@asutherland.org>
 * Mozilla Messaging, Inc.
 *
 * *****************************************************************************
 * IMPLEMENTATION DETAILS
 *
 * We are unable to emit an immediately usable speed tracer trace because the
 *  official trace format is tree-structured with nested child records.  Even
 *  if we ignored the semantic ramifications of nested event loops, we still
 *  have multiple threads doing things and we do care what all threads get up
 *  to.  If we had richer data structures available to us we could deal with the
 *  nesting and what not by only flushing top-level events when they are
 *  completed, but we don't have that.  Which is just as well because we'd still
 *  potentially need to set processor affinities.
 * 
 * So what we do is emit what is basically a flattened/augmented dialect of the
 *  speed tracer format that allows us to fairly easily reconstruct things into
 *  the official representation.  This has the positive side-effect of letting
 *  us use the bulk mode of operation for theoretically improved performance.
 *
 * We emit the following additional attributes for each event:
 * - tid: The thread id that this event occurred on.
 * - depth: The event depth for the current thread.
 * - tseq: The sequence of this event on this thread.  Parents have thread
 *    sequence numbers preceding their children.  We use this to provide
 *    certifiably correct reconstruction in the face of multiple threads on
 *    more than 2 cores given per-cpu buffers.  The nanosec timestamp values
 *    we also include may be more than sufficient for this and we may drop this
 *    once all the bugs are worked out of reconstruction.  (We only need this
 *    if threads can migrate across cores at a higher rate than the timing
 *    interval's maximum resolution.)
 *
 * We encode the following attributes differently:
 * - time: We store the number of nanoseconds since the start of the session
 *    rather than the number of milliseconds.  We've got'em, why not use'em?
 * - duration: We store the duration in nanoseconds instead of milliseconds.
 *
 * Events which have children are emitted after their children by virtue of how
 *  control flow works in this, our causal universe.
 *
 * Reconstruction amounts to postfix traversal.  We see every event's children
 *  before we see the event.  Imagine the following call-stack where time is
 *  flowing down, the indentation indicates call stack depth and the letters
 *  indicate each invocation and the meta-data off to the right:
 *   a     tseq: 0  depth: 0
 *    b    tseq: 1  depth: 1
 *     c   tseq: 2  depth: 2
 *     d   tseq: 3  depth: 2
 *    e    tseq: 4  depth: 1
 *     f   tseq: 5  depth: 2
 * This represents a calling two functions with the first call itself making two
 *  function calls and the second just one.  The event sequence produced by our
 *  probes would be: c, d, b, f, e, a.  Our logic goes like so:
 * - We see 'c' and have no current state.  We stick it in a list and tag it
 *    with depth 2.
 * - We see 'd'; it has the same depth as our current list, so we just stick it
 *    in there.
 * - We see 'b'; it has a depth less than our current list so we take the
 *    contents of the list and add them as children to 'b'.  We make a new list
 *    with 'b' in it and tag it with depth 1.
 * - We see 'f'; it has greater depth than our active 'b' list so we push a new
 *    list onto our stack with 'f' in it tagged with depth 2.
 * - We see 'e'; it has depth less than 'f' so we pop the list adding 'f' as a
 *    child.  The top list that holds 'b' has the same depth (1), so we add 'e'
 *    to that list.
 * - We see 'a'; it has depth less than the 'b' and 'e' list so we pop that list
 *    and add them as its children.
 *    
 *  
 *
 * *****************************************************************************
 * PROTOCOL NOTES
 *
 * - "sequence" attributes only appear to exist for top-level records and are
 *    present in child records (per mock logs).
 * - "usedHeapSize" and "totalHeapSize" are not used in the mock logs and it's
 *    not clear how the UI would surface them anyways?  I'll look into this when
 *    it comes time to attribute memory usage.
 */
//@@stapargs:-g,-DMAXSTRINGLEN=1024,-b,-s2,-v,-v,--all-modules
// "-g" allows us to use embedded C code
// "-DMAXSTRINGLEN=1024" allows us to process really long strings albeit with
//    some potential memory bloat.
// "-b" enables bulk mode transmission of data which means greatly reduced
//    userspace crossings (I think... we'll see! :).  Our driver automatically
//    adds an "-o" option.
// "-sNUM" NUM megabyte per-cpu buffers for bulk transfer
// "-v" is used to increase the debug
// "--all-modules" is used for the latencytap inclusion.

//@@postprocess:perfishpostproc

////////////////////////////////////////////////////////////////////////////////
//////// Memory Map Support

// Add logic to copy /proc/PID/maps to the output directory on entry to main
//  in case we are doing dynamic execution.

global g_copied_maps;

function copy_maps_if_needed() {
  if (!g_copied_maps) {
    g_copied_maps = 1;
    system(sprintf("cp /proc/%d/maps /tmp/chewtap-%d/maps", pid(), pid()));
  }
}

probe process(@@lib:bin/libxul.so).function("NS_LogInit_P") {
  copy_maps_if_needed();
}

////////////////////////////////////////////////////////////////////////////////
//////// Shared State

/** maps [thread] to current thread depth */
global t_depth;
/** maps [thread, depth] to start time */
global td_start;
/** maps [thread, depth] to pre-fetched data */
global td_pre_data;

global dawn_of_time;

/** global sequence counter to counter timer betrayals. */
global gseq;
/** maps [thread, depth] to global seq */
global td_seq;

probe begin {
  dawn_of_time = gettimeofday_ns();
  gseq = 0;
  g_copied_maps = 0;
}

function track_enter(eventCode, pre_data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx]++;

  // if we are depth 0, handle inter-event stuff...
  if ((depth == 0) && td_any_alloc[ctx, -1]) {
    printf("{\"tid\":%d,\"depth\":null,\"type\":null,\"mem\":{",
           ctx);
    mem_stats_data_string(ctx, -1);
    printf("}}\n");
    td_any_alloc[ctx, -1] = 0;
  }
  // clear the memory tracking for this context/depth
  td_any_alloc[ctx, depth] = 0;

  td_start[ctx, depth] = now;
  td_pre_data[ctx, depth] = pre_data;
  td_seq[ctx, depth] = gseq++;

  //printf("enter: %d @ %d ... %s\n", eventCode, depth, pre_data);
}

function track_leave(eventCode, data) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = --t_depth[ctx];

  // fix-up and bail if we were just catching the tail end of an event
  if (depth < 0) {
    t_depth[ctx] = 0;
  }
  else {
    start = td_start[ctx, depth];
    pre_data = td_pre_data[ctx, depth];
    seq = td_seq[ctx, depth];

    duration = now - start;

    //printf("exit: %d @ %d ... %s\n", eventCode, depth, data);

    printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":%d,\"time\":%d,\"duration\":%d,\"data\":{%s%s},\"mem\":{",
           ctx, seq, depth, eventCode,
           start - dawn_of_time, duration, pre_data, data);
    if (td_any_alloc[ctx, depth])
      mem_stats_data_string(ctx, depth);
    printf("}}\n");
  }
}


////////////////////////////////////////////////////////////////////////////////
//////// Memory Allocation Stuff

/*
 * The goals for tracking memory allocation are:
 * - Attribute memory activity to the containing event (or gaps when there is
 *    no active event.)
 * - Track general statistics for all (de)allocations; we want to know how
 *    many allocations occurred, how many frees occurred, and how many bytes
 *    were involved for each.  We want to be able to observe when death by
 *    paper cuts is happening for small and medium allocations.  For huge
 *    allocations we will be tracking their full life cycles, but it's nice to
 *    have the uniform presentation here too (and perhaps be able to turn off
 *    life-cycle.)
 * - Generate explicit events for all huge allocations (1 MiB and larger per
 *    jemalloc and us) so that we can directly track their life-cycles.
 * - reallocations are only really interesting 
 *
 * Here's the memory allocation scam:
 *
 *
 *
 * We maintain counters for count and total allocation size for a few different
 *  types of allocations for smaller allocations.  For larger allocations we
 *  emit their own JSON records so we can explicitly trace their life-cycle.
 *
 * kernel:
 * 0x0: mmap/munmap
 *
 * jemalloc:
 * 0x10: small
 * 0x11: large
 * 0x12: huge
 *
 * JS:
 * 0x40: object
 * 0x41: string
 * 0x42: function
 * 0x43: xml
 */

/** mapps [thread, depth] to whether any alloc happened */
global td_any_alloc;
/** maps [thread, depth, kind] to alloc count */
global tdk_mem_alloc_count;
/** maps [thread, depth, kind] to alloc byte tally */
global tdk_mem_alloc_bytes;
/** maps [thread, depth, kind] to realloc count */
global tdk_mem_realloc_count;
/** maps [thread, depth, kind] to realloc growth bytes */
global tdk_mem_realloc_bytes_growth;
/** maps [thread, depth, kind] to realloc shrink bytes */
global tdk_mem_realloc_bytes_shrink;
/** maps [thread, depth, kind] to free count */
global tdk_mem_free_count;
/** maps [thread, depth, kind] to free byte tally */
global tdk_mem_free_bytes;

function mem_stats_data_string(ctx, depth_idx) {
  // alloc
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x0]) {
    printf("\"kernel_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x0],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x0]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x0] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x0] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x10]) {
    printf("\"je_small_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x10],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x10]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x10] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x10] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x11]) {
    printf("\"je_large_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x11],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x11]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x11] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x11] = 0;
  }
  if (tdk_mem_alloc_count[ctx, depth_idx, 0x12]) {
    printf("\"je_huge_alloc\":[%d,%d],",
           tdk_mem_alloc_count[ctx, depth_idx, 0x12],
           tdk_mem_alloc_bytes[ctx, depth_idx, 0x12]);
    tdk_mem_alloc_count[ctx, depth_idx, 0x12] = 0;
    tdk_mem_alloc_bytes[ctx, depth_idx, 0x12] = 0;
  }

  // realloc
  if (tdk_mem_realloc_count[ctx, depth_idx, 0x1]) {
    printf("\"je_realloc\":[%d,%d,%d],",
           tdk_mem_realloc_count[ctx, depth_idx, 0x1],
           tdk_mem_realloc_bytes_growth[ctx, depth_idx, 0x1],
           tdk_mem_realloc_bytes_shrink[ctx, depth_idx, 0x1]);
    tdk_mem_realloc_count[ctx, depth_idx, 0x1] = 0;
    tdk_mem_realloc_bytes_growth[ctx, depth_idx, 0x1] = 0;
    tdk_mem_realloc_bytes_shrink[ctx, depth_idx, 0x1] = 0;
  }
  
  // free
  if (tdk_mem_free_count[ctx, depth_idx, 0x0]) {
    printf("\"kernel_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x0],
           tdk_mem_free_bytes[ctx, depth_idx, 0x0]);
    tdk_mem_free_count[ctx, depth_idx, 0x0] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x0] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x10]) {
    printf("\"je_small_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x10],
           tdk_mem_free_bytes[ctx, depth_idx, 0x10]);
    tdk_mem_free_count[ctx, depth_idx, 0x10] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x10] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x11]) {
    printf("\"je_large_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x11],
           tdk_mem_free_bytes[ctx, depth_idx, 0x11]);
    tdk_mem_free_count[ctx, depth_idx, 0x11] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x11] = 0;
  }
  if (tdk_mem_free_count[ctx, depth_idx, 0x12]) {
    printf("\"je_huge_free\":[%d,%d],",
           tdk_mem_free_count[ctx, depth_idx, 0x12],
           tdk_mem_free_bytes[ctx, depth_idx, 0x12]);
    tdk_mem_free_count[ctx, depth_idx, 0x12] = 0;
    tdk_mem_free_bytes[ctx, depth_idx, 0x12] = 0;
  }
}

function mem_stats_track_alloc(kind, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_alloc_count[ctx, depth_idx, kind]++;
  tdk_mem_alloc_bytes[ctx, depth_idx, kind] += size;
}

function mem_stats_track_realloc(kind, oldsize, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;
  delta = size - oldsize;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_realloc_count[ctx, depth_idx, kind]++;
  if (delta > 0)
    tdk_mem_realloc_bytes_growth[ctx, depth_idx, kind] += delta;
  else
    tdk_mem_realloc_bytes_shrink[ctx, depth_idx, kind] += delta;
}

function mem_stats_track_free(kind, size) {
  ctx = tid();
  depth_idx = t_depth[ctx] - 1;

  td_any_alloc[ctx, depth_idx] = 1;
  tdk_mem_free_count[ctx, depth_idx, kind]++;
  tdk_mem_free_bytes[ctx, depth_idx, kind] += size;
}

function mem_life_cycle_alloc(kind, ptr, size) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"alloc\",\"time\":%d,\"data\":{\"source\":%d,\"ptr\":%d,\"size\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, ptr, size);
}

function mem_life_cycle_realloc(kind, oldptr, newptr, oldsize, newsize) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"realloc\",\"time\":%d,\"data\":{\"source\":%d,\"oldptr\":%d,\"newptr\":%d,\"oldsize\":%d,\"newsize\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, oldptr, newptr, oldsize, newsize);
}

function mem_life_cycle_free(kind, ptr, size) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];

  printf("{\"tid\":%d,\"depth\":%d,\"mtype\":\"free\",\"time\":%d,\"data\":{\"source\":%d,\"ptr\":%d,\"size\":%d}}\n",
         ctx, depth,
         now - dawn_of_time, kind, ptr, size);
}


////////////////////////////////////////////////////////////////////////////////
//// kernel

// too expensive!!
/*
// the vm.mmap point wants do_mmap/do_mmap2 which we cannot have...
probe kernel.function("do_mmap_pgoff") {
  if (pid() != target())
    next;

  address = $addr;
  length = $len;
  mem_stats_track_alloc(0x0, length);
  mem_life_cycle_alloc(0x0, address, length);
}

probe vm.munmap {
  if (pid() != target())
    next;

  mem_stats_track_free(0x0, length);
  mem_life_cycle_free(0x0, address, length);
}
*/

////////////////////////////////////////////////////////////////////////////////
//// jemalloc

// jemalloc gets linked into thunderbird-bin proper
// the following are defined in terms of other exposed operations:
// - posix_memalign in terms of memalign
// - valign in terms of memalign

// arena_malloc_small
// arena_malloc_large
// huge_malloc

// ???
// arena_palloc, huge_palloc

// arena_ralloc
// huge_ralloc

// arena_dalloc_small
// arena_dalloc_large
// huge_dalloc



//// alloc

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_malloc_small
//@@lineseek:arena_malloc_small(arena_t *arena, size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@exe:).statement(@@statement:ref) {
  mem_stats_track_alloc(0x10, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_malloc_large
//@@lineseek:arena_malloc_large(arena_t *arena, size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@exe:).statement(@@statement:ref) {
  mem_stats_track_alloc(0x11, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_malloc
//@@lineseek:huge_malloc(size_t size, bool zero)
//@@lineseek:if (ret == NULL) {
probe process(@@exe:).statement(@@statement:ref) {
  size = $size;
  mem_stats_track_alloc(0x12, size);
  mem_life_cycle_alloc(0x12, $ret, size);
}

//// realloc

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:iralloc
//@@lineseek:iralloc(void *ptr, size_t size)
//@@lineseek:if (size <= arena_maxclass)
probe process(@@exe:).statement(@@statement:ref) {
  mem_stats_track_realloc(0x1, $oldsize, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_ralloc
//@@lineseek:huge_ralloc(void *ptr, size_t size, size_t oldsize)
//@@lineseek:if (ret == NULL)
probe process(@@exe:).statement(@@statement:ref) {
  mem_life_cycle_realloc(0x12, $ptr, $ret, $oldsize, $size);
}


//// free

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_dalloc_small
//@@lineseek:arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
//@@lineseek:arena_run_reg_dalloc(run, bin, ptr, size);
probe process(@@exe:).statement(@@statement:ref) {
  mem_stats_track_free(0x10, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:arena_dalloc_large
//@@lineseek:arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
// MALLOC_STATS is always defined for us, so this line will always be available
//@@lineseek:arena->stats.allocated_large -= size;
probe process(@@exe:).statement(@@statement:ref) {
  mem_stats_track_free(0x11, $size);
}

//@@file:mozilla/memory/jemalloc/jemalloc.c
//@@method:huge_dalloc
//@@lineseek:huge_dalloc(void *ptr)
//@@lineseek:extent_tree_ad_remove(&huge, node);
probe process(@@exe:).statement(@@statement:ref) {
  size = $node->size;
  mem_stats_track_free(0x12, size);
  mem_life_cycle_free(0x12, $ptr, size);
}


////////////////////////////////////////////////////////////////////////////////
//// JavaScript

/*
 * SpiderMonkey uses arenas.
 */

/*
probe process(@@lib:bin/libxul.so).function("NewGCArena") {
}
*/

/*
 * There's a NewGCThing<T> template that we could probably wildcard, but the
 *  apparent use count is low enough it seems worth it to specialize here...
 */

/*
probe process(@@lib:bin/libxul.so).function("js_NewGCObject") {
}

probe process(@@lib:bin/libxul.so).function("js_NewGCString") {
}

probe process(@@lib:bin/libxul.so).function("js_NewGCFunction") {
}

probe process(@@lib:bin/libxul.so).function("js_NewGCXML") {
}
*/

////////////////////////////////////////////////////////////////////////////////
//////// Browser Timeline Events

////////////////////////////////////////////////////////////////////////////////
//// DOM_EVENT : 0

////////////////////////////////////////////////////////////////////////////////
//// LAYOUT : 1

probe process(@@lib:bin/libxul.so).function("PresShell::DoReflow") {
  track_enter(1, "");
}

// returns false when interrupted, true when completed
probe process(@@lib:bin/libxul.so).function("PresShell::DoReflow").return {
  track_leave(1, "");
}


////////////////////////////////////////////////////////////////////////////////
//// RECALC_STYLE : 2

// These are also somewhat related to PresShell::FlushPendingNotifications, but
//  the hope is that we catch all that through specific coverage of its
//  children.

probe process(@@lib:bin/libxul.so).function("nsCSSFrameConstructor::ProcessPendingRestyles") {
  track_enter(2, "");
}

probe process(@@lib:bin/libxul.so).function("nsCSSFrameConstructor::ProcessPendingRestyles").return {
  track_leave(2, "");
}

////////////////////////////////////////////////////////////////////////////////
//// PAINT : 3

probe process(@@lib:bin/libxul.so).function("PresShell::Paint") {
  data = sprintf("\"x\":%d,\"y\":%d,\"width\":%d,\"height\":%d",
                 $aDirtyRegion->mBoundRect->x, $aDirtyRegion->mBoundRect->y,
                 $aDirtyRegion->mBoundRect->width,
                 $aDirtyRegion->mBoundRect->height);
  track_enter(3, data);
}

// returns false when interrupted, true when completed
probe process(@@lib:bin/libxul.so).function("PresShell::Paint").return {
  track_leave(3, "");
}

////////////////////////////////////////////////////////////////////////////////
//// PARSE_HTML : 4

////////////////////////////////////////////////////////////////////////////////
//// TIMER_INSTALLED : 5


// === nsITimer

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::InitCommon
//@@lineseek:nsresult nsTimerImpl::InitCommon(PRUint32 aType, PRUint32 aDelay)
//@@lineseek:SetDelayInternal(aDelay);
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];
  seq = gseq++;

  singleShot = ($aType == 0);
  printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":5,\"time\":%d,\"data\":{\"timerId\":%d,\"singleShot\":%d,\"timeout\":%d}}\n",
         ctx, seq, depth,
         now - dawn_of_time, $this, singleShot, $aDelay);
}


////////////////////////////////////////////////////////////////////////////////
//// TIMER_CLEARED : 6

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Cancel
//@@lineseek:NS_IMETHODIMP nsTimerImpl::Cancel()
//@@lineseek:mCanceled = PR_TRUE;
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];
  seq = gseq++;

  printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":6,\"time\":%d,\"data\":{\"timerId\":%d}}\n",
         ctx, seq, depth,
         now - dawn_of_time, $this);
}

////////////////////////////////////////////////////////////////////////////////
//// TIMER_FIRED : 7

// === Global Window setTimeout/setInterval timers
// we just note the JS boundary crossing here

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  if ($scriptObject)
    track_enter(15, ""); // but we're calling into JS here...
}

// the eval case
//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:PRBool is_undefined;
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  data = sprintf("\"scriptName\":\"%s\",\"scriptLine\":%d",
                 user_string($filename), $lineNo);
  track_enter(15, data);
}

//@@file:mozilla/dom/base/nsGlobalWindow.cpp
//@@method:nsGlobalWindow::RunTimeout
//@@lineseek:nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
//@@lineseek:if (!scriptObject) {
//@@lineseek:handler = nsnull; // drop reference before dropping timeout refs.
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  scriptObj = $scriptObject;
  // the non-scriptObj case is handled by the preceding probe
  if (scriptObj) {
    // the scriptObj, although void, is really a JSObject* of variety
    //  JSFunction*, or at least we are assuming that :)
    data = script_info_from_jsfunobj(scriptObj);
    track_leave(15, data);
  }
  else {
    track_leave(15, "");
  }
}

/**
 * Takes a pointer to a C++ instance that relies on virtual dispatch and
 *  returns the contents of the first pointer from that instance which will
 *  be a pointer to the/a vtbl.  Even in the case where we are actually
 *  getting a sliced vtable, the address will still be 'within' the range
 *  attributed to the specific class.
 */
function get_vtbl_ptr_from_instance(ptr) {
  return @cast(ptr, "PRUptrdiff", @@lib:lib/libnspr4.so)[0];
}

// === nsITimer (convertible to Global Window)

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_enter(7, "");

  // fake an entry to say where we are going, native-like.
  if ($callbackType == 2)
    timerAddr = $callback->c;
  else
    timerAddr = get_vtbl_ptr_from_instance($callback->i);

  data = sprintf("\"scriptName\":\":!vt:%x\",\"scriptLine\":0", timerAddr);
  track_enter(15, data);
}

//@@file:mozilla/xpcom/threads/nsTimerImpl.cpp
//@@method:nsTimerImpl::Fire
//@@lineseek:if (callbackType == CALLBACK_TYPE_INTERFACE)
//@@lineseek:mFiring = PR_FALSE;
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_leave(15, "");
  track_leave(7, sprintf("\"timerId\":%d", $this));
}


////////////////////////////////////////////////////////////////////////////////
//// XHR_READY_STATE_CHANGE : 8

////////////////////////////////////////////////////////////////////////////////
//// XHR_LOAD : 9

////////////////////////////////////////////////////////////////////////////////
//// EVAL_SCRIPT : 10

////////////////////////////////////////////////////////////////////////////////
//// LOG_MESSAGE : 11

// These come from console.markTimeline(message) calls in Chrome.  We could
//  accomplish the same thing if we exposed a native or found an existing native
//  we could co-opt.  dump is co-optable given that its rate of invocation is
//  low enough that we could perform a simple string formatting rule to
//  determine what wants actually wants to get logged.


// XXX this is xpcshell-only; this really needs to be conditionalized.

//@@file:mozilla/js/src/xpconnect/shell/xpcshell.cpp
//@@method:Dump
//@@lineseek:Dump(JSContext *cx, uintN argc, jsval *vp)
//@@lineseek:fflush(gOutFile);
probe process(@@exe:).statement(@@statement:ref),
// XXX all the rest of these don't really need to reget the chars, but we
//  reuse the code block because we can (and our only escaping logic right
//  now also happens to be in the 16->8 logic.)
//@@file:mozilla/js/src/xpconnect/loader/mozJSComponentLoader.cpp
//@@method:Dump
//@@lineseek:Dump(JSContext *cx, uintN argc, jsval *vp)
//@@lineseek:fputs(NS_ConvertUTF16toUTF8(reinterpret_cast<const PRUnichar*>(chars)).get(), stderr);
 process(@@lib:bin/libxul.so).statement(@@statement:ref),
//@@file:mozilla/js/src/xpconnect/src/xpccomponents.cpp
//@@method:SandboxDump
//@@lineseek:SandboxDump(JSContext *cx, uintN argc, jsval *vp)
//@@lineseek:if (!chars)
 process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  copy_maps_if_needed();

  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];
  seq = gseq++;

  // the bad news is that we have to re-do the work of JS_GetStringBytes
  //  because its output does not stay in a temporary we can get at.
  // (arguments start at 2; see JS_ARGV which is all addy)
  // the good news is that since we are running after the JS_GetStringBytes
  //  it will already have flattened the string for us so we don't need to deal
  //  with the horrible horrors of ropes.
  msg = jsstr_to_string($str);

  printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":11,\"time\":%d,\"data\":{\"message\":\"%s\"}}\n",
         ctx, seq, depth,
         now - dawn_of_time, msg);  
}

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_START : 12

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_RESPONSE: 13

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_FINISH : 14

////////////////////////////////////////////////////////////////////////////////
//// JAVASCRIPT_CALLBACK : 15

////////////////////////////////////////////////////////////////////////////////
//// RESOURCE_DATA_RECEIVED : 16

////////////////////////////////////////////////////////////////////////////////
//// GC_EVENT : 17

probe process(@@lib:bin/libxul.so).function("js_GC") {
  track_enter(17, "");
}

probe process(@@lib:bin/libxul.so).function("js_GC").return {
  track_leave(17, "");
}


////////////////////////////////////////////////////////////////////////////////
//// MARK_DOM_CONTENT : 18

////////////////////////////////////////////////////////////////////////////////
//// MARK_LOAD_EVENT : 19

////////////////////////////////////////////////////////////////////////////////
//////// Speed Tracer Events

////////////////////////////////////////////////////////////////////////////////
//// TAB_CHANGED : 0x7f ff ff fe

////////////////////////////////////////////////////////////////////////////////
//// NETWORK_RESOURCE_UPDATE : 0x7f ff ff fd

////////////////////////////////////////////////////////////////////////////////
//// PROFILE_DATA : 0x7f ff ff fc

// The documentation really cops out here (but avoids calling attention to it :)


////////////////////////////////////////////////////////////////////////////////
//////// Mozilla Made-Up Events

////////////////////////////////////////////////////////////////////////////////
//// Event Loop : 0x1000+

// === Event scheduling (0x1001 = 4097)

// We place ourselves in the PutEvent logic so that we cover the synchronous
//  and normal cases.  We, of course, need to make sure that our probe point
//  happens before the actual enqueuing, otherwise we may end up seeing the
//  scheduling after the event runs!  This could result in us seeing an event
//  being scheduled that actually gets dropped on the floor.  But that should
//  only happen at shutdown or if we are out of memory, both of which are
//  going to be right before the process dies a horrible death.

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::PutEvent
//@@lineseek:nsThread::PutEvent(nsIRunnable *event)
//@@lineseek:if (mEventsAreDoomed) {
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  now = gettimeofday_ns();
  ctx = tid();
  depth = t_depth[ctx];
  seq = gseq++;

  printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":4097,\"time\":%d,\"data\":{\"eventId\":%d,\"threadId\":%d,\"jsstack\":",
         ctx, seq, depth,
         now - dawn_of_time, $event, $this);
  // dump a jsstack if we can find one
  dump_jsstack_under_native();
  printf("}}\n");
}


// === Event execution (0x1000 = 4096)

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  // $event->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  rawPtr = $event->mRawPtr;
  if (rawPtr)
    eventAddr = get_vtbl_ptr_from_instance(rawPtr);
  else
    eventAddr = 0;

  data = sprintf("\"eventId\":%d,\"threadId\":%d,\"scriptName\":\":!vt:%x\",\"scriptLine\":0",
                 rawPtr, $this, eventAddr);
  track_enter(0x1000, data);
}

//@@file:mozilla/xpcom/threads/nsThread.cpp
//@@method:nsThread::ProcessNextEvent
//@@lineseek:nsThread::ProcessNextEvent(PRBool mayWait, PRBool *result)
//@@lineseek:if (event) {
//@@lineseek:--mRunningEvent;
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_leave(0x1000, "");
}



////////////////////////////////////////////////////////////////////////////////
//// InputStreamReadyEvent : 0x1020

probe process(@@lib:bin/libxul.so).function("nsInputStreamReadyEvent::Run") {
  // $mCallback->mRawPtr's value is the address of an instance on the heap
  // The first pointer at that location is the pointer to the vtable.
  callbackAddr = get_vtbl_ptr_from_instance($this->mCallback->mRawPtr);

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1020, data);
}

probe process(@@lib:bin/libxul.so).function("nsInputStreamReadyEvent::Run").return {
  track_leave(0x1020, "");
}


////////////////////////////////////////////////////////////////////////////////
//// nsInputStreamPump::OnInputStreamReady : 0x1021

//@@file:mozilla/netwerk/base/src/nsInputStreamPump.cpp
//@@method:nsInputStreamPump::OnInputStreamReady
//@@lineseek:nsInputStreamPump::OnInputStreamReady(nsIAsyncInputStream *stream)
//@@lineseek:LOG(("nsInputStreamPump::OnInputStreamReady [this=%x]\n", this));
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  rawPtr = $this->mListener->mRawPtr;
  if (rawPtr)
    callbackAddr = get_vtbl_ptr_from_instance(rawPtr);
  else
    callbackAddr = 0;

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1021, data);
}

probe process(@@lib:bin/libxul.so).function("nsInputStreamPump::OnInputStreamReady").return {
  track_leave(0x1021, "");
}


////////////////////////////////////////////////////////////////////////////////
//// XPConnect -> JS Crossing : 0x1040

/** maps [thread] to current thread depth... */
global t_jscx_depth;
/** maps [thread, depth] to current JSContext */
global td_jscx_ptr;

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = JS_CallFunctionValue(cx, thisObj, fval, argc, argv, &rval);
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_enter(0x1040, "");

  ctx = tid();
  depth = t_jscx_depth[ctx]++;
  td_jscx_ptr[ctx, depth] = $cx;
}

//@@file:mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp
//@@method:nsXPCWrappedJSClass::CallMethod
//@@lineseek:success = JS_CallFunctionValue(cx, thisObj, fval, argc, argv, &rval);
//@@lineseek:JS_SetOptions(cx, oldOpts);
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  // fval is a jsval... get the pointer out of it
  data = script_info_from_jsfunobj($fval->asBits & 0x00007FFFFFFFFFFF);
  track_leave(0x1040, data);

  ctx = tid()
  depth = --t_jscx_depth[ctx];
  td_jscx_ptr[ctx, depth] = 0; // null it out; weird stuff is happening.
  // (XXX should we delete instead?)
}


////////////////////////////////////////////////////////////////////////////////
//// native -> JS Crossing via JS_ExecuteScript : 0x1041

/*
 * This crossing happens inside:
 * - xpcshell's ProcessFile routine (the bit we really want to target)
 * - nsDOMWorkerScriptLoader::ExecuteScripts: Called by LoadScripts which can
 *    happen as a result of the initial worker setup (SetGlobalForContext) or
 *    due to a call to 'importScripts' from inside the worker.
 * - nsJSContext::ExecuteScript in mozilla/dom/base's ExecuteScript, who
 *    does not seem to have any callers somehow?  macrology must be at play
 *    or a refactoring orphaned it or something...
 * - mozJSComponentLoader::GlobalForLocation which is used by LoadModuleImpl and
 *    ImportInto.
 * - nsFrameScriptExecutor::LoadFrameScriptInternal which would appear to be
 *    related to IPC stuff that is mysterious.
 */

//@@file:mozilla/js/src/jsapi.cpp
//@@method:JS_ExecuteScript
//@@lineseek:ok = Execute(cx, obj, script, NULL, 0, Valueify(rval));
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_enter(0x1041, "");

  ctx = tid();
  depth = t_jscx_depth[ctx]++;
  td_jscx_ptr[ctx, depth] = $cx;
}

//@@file:mozilla/js/src/jsapi.cpp
//@@method:JS_ExecuteScript
//@@lineseek:ok = Execute(cx, obj, script, NULL, 0, Valueify(rval));
//@@lineseek:return ok;
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  track_leave(0x1041, script_info_from_jsscript($script));

  ctx = tid()
  depth = --t_jscx_depth[ctx];
  td_jscx_ptr[ctx, depth] = 0; // null it out; weird stuff is happening.
}


////////////////////////////////////////////////////////////////////////////////
//// nsProxyObjectCallInfo : 0x1060

// the prologue logic is not working on this dude, need to move to a statement
//probe process(@1).function("nsProxyObjectCallInfo::Run")
//@@file:mozilla/xpcom/proxy/src/nsProxyEvent.cpp
//@@method:nsProxyObjectCallInfo::Run
//@@lineseek:nsProxyObjectCallInfo::Run()
//@@lineseek:mResult = NS_InvokeByIndex(mOwner->GetProxiedInterface(),
probe process(@@lib:bin/libxul.so).statement(@@statement:ref) {
  rawPtr = $this->mOwner->mRawPtr->mProxyObject->mRawPtr->mRealObject->mRawPtr;
  callbackAddr = get_vtbl_ptr_from_instance(rawPtr);

  data = sprintf("\"scriptName\":\":!vt:%x\"", callbackAddr);
  track_enter(0x1060, data);
}

probe process(@@lib:bin/libxul.so).function("nsProxyObjectCallInfo::Run").return {
  track_leave(0x1060, "");
}


////////////////////////////////////////////////////////////////////////////////
//// mozStorage async : 0x1080

// I think the standard nsIEventTarget::dispatch logic should infer causality
//  sufficiently to start with, so do not explicitly handle this for now.  We
//  may end up caring 

////////////////////////////////////////////////////////////////////////////////
////// latencytap transplant : 0x2000

/*
 * all of this is ported frmo latencytap.stp, which is:
 *
 */
global lt_priority, lt_reason;
global traced_pid, dequeue;
global lt_this_sleep;

function log_event:long (p:long) { return (!traced_pid || traced_pid == p) }

# pick out a lt_reason based on the backtrace function names
function translate:string (bt:string)
{
  ip=tokenize(bt, " ");
  func = symname(strtol(ip,16))
  pri = 1; rea="";
  while (ip!="") {
    p = lt_priority[func]
    if (p >= pri) {
      pri = lt_priority[func];
      rea = lt_reason[func];
    }
    ip=tokenize("", " ")
    func = symname(strtol(ip,16))
  }
  return rea;
}

probe kernel.trace("deactivate_task") !,
      kernel.function("deactivate_task") {
  s = task_state($p)
  # check to see if task is in appropriate state:
  # TASK_INTERRUPTIBLE      1
  # TASK_UNINTERRUPTIBLE    2
  if (log_event($p->pid) && (s & 3)) {
    dequeue[$p] = gettimeofday_ns();
  }
}

probe kernel.trace("activate_task") !,
      kernel.function("activate_task") {
  if (!log_event($p->pid)) next

  a = gettimeofday_ns()
  d = dequeue[$p]
  if (d) {
    sleep = a - d
    if (sleep > 1000) {
       lt_this_sleep[$p] = sleep
#      sleep_time[task_backtrace($p)] <<< sleep
    }
    else {
      delete dequeue[$p]
    }
  }
  else {
    delete dequeue[$p]
  }
}

#FIXME: It would be nicer to get backtrace information in activate_task probe.
# This would eliminate the overhead of probing every context switch
# and lt_this_sleep associate array. However, this needs a properly working
# task_backtrace() to eliminate this probe.
probe scheduler.cpu_on {
   p = task_current()
   t = lt_this_sleep[p]
   if (t){
     seq = gseq++;
     ctx = tid();
     depth = t_depth[ctx];

     d = dequeue[p];
     delete lt_this_sleep[p]
     delete dequeue[p]

     // if it took more than .1 millisec, get a backtrace
     if (t > 100000) {
       printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":8192,\"time\":%d,\"duration\":%d,\"data\":{\"reason\":\"%s\",\"jsstack\":",
              ctx, seq, depth, 
              d - dawn_of_time, t, translate(backtrace()));
       dump_jsstack_under_native();
       // don't bother with a native backtrace; we keep only getting 1 frame and
       //  I think it may be crashing my computer a wee bit.
       printf("}}\n");
     }
     else {
       printf("{\"tid\":%d,\"gseq\":%d,\"depth\":%d,\"type\":8192,\"time\":%d,\"duration\":%d,\"data\":{\"reason\":\"%s\"}}\n",
              ctx, seq, depth, 
              d - dawn_of_time, t, translate(backtrace()));
     }
   }
}

probe begin {
  traced_pid = target()
}

# Set up the translations and priorities for each function.
probe begin {
  lt_priority["vfs_read"] = 1;
  lt_reason["vfs_read"] = "Reading from file";

  lt_priority["vfs_write"] = 1;
  lt_reason["vfs_write"] = "Writing to file";

  lt_priority["__mark_inode_dirty"] = 1;
  lt_reason["__mark_inode_dirty"] = "Marking inode dirty";

  lt_priority["vfs_readdir"] = 1;
  lt_reason["vfs_readdir"] = "Reading directory content";

  lt_priority["vfs_unlink"] = 1;
  lt_reason["vfs_unlink"] = "Unlinking file";

  lt_priority["blocking_notifier_call_chain"] = 1;
  lt_reason["blocking_notifier_call_chain"] = "Blocking notifier";

  lt_priority["lock_super"] = 1;
  lt_reason["lock_super"] = "Superblock lock contention";

  lt_priority["bdi_sync_supers"] = 1;
  lt_reason["bdi_sync_supers"] = "Sync superblock";

  lt_priority["vfs_create"] = 1;
  lt_reason["vfs_create"] = "Creating a file";

  lt_priority["__bread"] = 2;
  lt_reason["__bread"] = "Synchronous buffer read";

  lt_priority["do_generic_mapping_read"] = 2;
  lt_reason["do_generic_mapping_read"] = "Reading file data";

  lt_priority["sock_sendmsg"] = 2;
  lt_reason["sock_sendmsg"] = "Sending data over socket";

  lt_priority["do_sys_open"] = 2;
  lt_reason["do_sys_open"] = "Opening file";

  lt_priority["do_sys_poll"] = 2;
  lt_reason["do_sys_poll"] = "Waiting for event (poll)";

  lt_priority["core_sys_select"] = 2;
  lt_reason["core_sys_select"] = "Waiting for event (select)";

  lt_priority["proc_reg_read"] = 2;
  lt_reason["proc_reg_read"] = "Reading from /proc file";

  lt_priority["__pollwait"] = 2;
  lt_reason["__pollwait"] = "Waiting for event (poll)";

  lt_priority["sys_fcntl"] = 2;
  lt_reason["sys_fcntl"] = "FCNTL system call";

  lt_priority["scsi_error_handler"] = 2;
  lt_reason["scsi_error_handler"] = "SCSI error handler";

  lt_priority["proc_root_readdir"] = 2;
  lt_reason["proc_root_readdir"] = "Reading /proc directory";

  lt_priority["ksoftirqd"] = 2;
  lt_reason["ksoftirqd"] = "Waking ksoftirqd";

  lt_priority["run_ksoftirqd"] = 2;
  lt_reason["run_ksoftirqd"] = "Waking ksoftirqd";

  lt_priority["migration_thread"] = 2;
  lt_reason["migration_thread"] = "migration() kernel thread";

  lt_priority["do_unlinkat"] = 2;
  lt_reason["do_unlinkat"] = "Unlinking file";

  lt_priority["__wait_on_buffer"] = 2;
  lt_reason["__wait_on_buffer"] = "Waiting for buffer IO to complete";

  lt_priority["pdflush"] = 2;
  lt_reason["pdflush"] = "pdflush() kernel thread";

  lt_priority["kjournald"] = 2;
  lt_reason["kjournald"] = "kjournald() kernel thread";

  lt_priority["kjournald2"] = 2;
  lt_reason["kjournald2"] = "jdb2() kernel thread";

  lt_priority["bdi_writeback_task"] = 2;
  lt_reason["bdi_writeback_task"] = "Flush data to backing device";

  lt_priority["bdi_writeback_thread"] = 2;
  lt_reason["bdi_writeback_thread"] = "Flush data to backing dev";

  lt_priority["bdi_forker_task"] = 2;
  lt_reason["bdi_forker_task"] = "bdi-* kernel thread";

  lt_priority["dm_wait_for_completion"] = 2;
  lt_reason["dm_wait_for_completion"] = "Waiting for device mapper ops";

  lt_priority["blkdev_ioctl"] = 2;
  lt_reason["blkdev_ioctl"] = "block device IOCTL";

  lt_priority["kauditd_thread"] = 2;
  lt_reason["kauditd_thread"] = "kernel audit daemon";

  lt_priority["tty_ioctl"] = 2;
  lt_reason["tty_ioctl"] = "TTY IOCTL";

  lt_priority["do_sync_write"] = 2;
  lt_reason["do_sync_write"] = "synchronous write";

  lt_priority["kthreadd"] = 2;
  lt_reason["kthreadd"] = "kthreadd kernel thread";

  lt_priority["usb_port_resume"] = 2;
  lt_reason["usb_port_resume"] = "Waking up USB device";

  lt_priority["usb_autoresume_device"] = 2;
  lt_reason["usb_autoresume_device"] = "Waking up USB device";

  lt_priority["khugepaged"] = 2;
  lt_reason["khugepaged"] = "khugepaged() kernel thread";

  lt_priority["kswapd"] = 2;
  lt_reason["kswapd"] = "kswapd() kernel thread";

  lt_priority["md_thread"] = 2;
  lt_reason["md_thread"] = "Raid resync kernel thread";

  lt_priority["i915_wait_request"] = 2;
  lt_reason["i915_wait_request"] = "Waiting for GPU command to complete";

  lt_priority["request_module"] = 2;
  lt_reason["request_module"] = "Loading a kernel module";

  lt_priority["tty_wait_until_sent"] = 3;
  lt_reason["tty_wait_until_sent"] = "Waiting for TTY to finish sending";

  lt_priority["pipe_read"] = 3;
  lt_reason["pipe_read"] = "Reading from a pipe";

  lt_priority["pipe_write"] = 3;
  lt_reason["pipe_write"] = "Writing to a pipe";

  lt_priority["pipe_wait"] = 3;
  lt_reason["pipe_wait"] = "Waiting for pipe data";

  lt_priority["read_block_bitmap"] = 3;
  lt_reason["read_block_bitmap"] = "Reading EXT3 block bitmaps";

  lt_priority["scsi_execute_req"] = 3;
  lt_reason["scsi_execute_req"] = "Executing raw SCSI command";

  lt_priority["sys_wait4"] = 3;
  lt_reason["sys_wait4"] = "Waiting for a process to die";

  lt_priority["sr_media_change"] = 3;
  lt_reason["sr_media_change"] = "Checking for media change";

  lt_priority["sr_do_ioctl"] = 3;
  lt_reason["sr_do_ioctl"] = "SCSI cdrom ioctl";

  lt_priority["sd_ioctl"] = 3;
  lt_reason["sd_ioctl"] = "SCSI disk ioctl";

  lt_priority["sr_cd_check"] = 3;
  lt_reason["sr_cd_check"] = "Checking CDROM media present";

  lt_priority["ext3_read_inode"] = 3;
  lt_reason["ext3_read_inode"] = "Reading EXT3 inode";

  lt_priority["htree_dirblock_to_tree"] = 3;
  lt_reason["htree_dirblock_to_tree"] = "Reading EXT3 directory htree";

  lt_priority["ext3_readdir"] = 3;
  lt_reason["ext3_readdir"] = "Reading EXT3 directory";

  lt_priority["ext3_bread"] = 3;
  lt_reason["ext3_bread"] = "Synchronous EXT3 read";

  lt_priority["ext3_free_branches"] = 3;
  lt_reason["ext3_free_branches"] = "Unlinking file on EXT3";

  lt_priority["ext3_get_branch"] = 3;
  lt_reason["ext3_get_branch"] = "Reading EXT3 indirect blocks";

  lt_priority["ext3_find_entry"] = 3;
  lt_reason["ext3_find_entry"] = "EXT3: Looking for file";

  lt_priority["__ext3_get_inode_loc"] = 3;
  lt_reason["__ext3_get_inode_loc"] = "Reading EXT3 inode";

  lt_priority["ext3_delete_inode"] = 3;
  lt_reason["ext3_delete_inode"] = "EXT3 deleting inode";

  lt_priority["sync_page"] = 3;
  lt_reason["sync_page"] = "Writing a page to disk";

  lt_priority["tty_poll"] = 3;
  lt_reason["tty_poll"] = "Waiting for TTY data";

  lt_priority["tty_read"] = 3;
  lt_reason["tty_read"] = "Waiting for TTY input";

  lt_priority["tty_write"] = 3;
  lt_reason["tty_write"] = "Writing data to TTY";

  lt_priority["update_atime"] = 3;
  lt_reason["update_atime"] = "Updating inode atime";

  lt_priority["page_cache_sync_readahead"] = 3;
  lt_reason["page_cache_sync_readahead"] = "Pagecache sync readahead";

  lt_priority["do_fork"] = 3;
  lt_reason["do_fork"] = "Fork() system call";

  lt_priority["sys_mkdirat"] = 3;
  lt_reason["sys_mkdirat"] = "Creating directory";

  lt_priority["lookup_create"] = 3;
  lt_reason["lookup_create"] = "Creating file";

  lt_priority["inet_sendmsg"] = 3;
  lt_reason["inet_sendmsg"] = "Sending TCP/IP data";

  lt_priority["tcp_recvmsg"] = 3;
  lt_reason["tcp_recvmsg"] = "Receiving TCP/IP data";

  lt_priority["link_path_walk"] = 3;
  lt_reason["link_path_walk"] = "Following symlink";

  lt_priority["path_walk"] = 3;
  lt_reason["path_walk"] = "Walking directory tree";

  lt_priority["sys_getdents"] = 3;
  lt_reason["sys_getdents"] = "Reading directory content";

  lt_priority["unix_stream_recvmsg"] = 3;
  lt_reason["unix_stream_recvmsg"] = "Waiting for data on unix socket";

  lt_priority["ext3_mkdir"] = 3;
  lt_reason["ext3_mkdir"] = "EXT3: Creating a directory";

  lt_priority["journal_get_write_access"] = 3;
  lt_reason["journal_get_write_access"] = "EXT3: Waiting for journal access";

  lt_priority["synchronize_rcu"] = 3;
  lt_reason["synchronize_rcu"] = "Waiting for RCU";

  lt_priority["input_close_device"] = 3;
  lt_reason["input_close_device"] = "Closing input device";

  lt_priority["mousedev_close_device"] = 3;
  lt_reason["mousedev_close_device"] = "Closing mouse device";

  lt_priority["mousedev_release"] = 3;
  lt_reason["mousedev_release"] = "Closing mouse device";

  lt_priority["mousedev_open"] = 3;
  lt_reason["mousedev_open"] = "Opening mouse device";

  lt_priority["kmsg_read"] = 3;
  lt_reason["kmsg_read"] = "Reading from dmesg";

  lt_priority["sys_futex"] = 3;
  lt_reason["sys_futex"] = "Userspace lock contention";

  lt_priority["do_futex"] = 3;
  lt_reason["do_futex"] = "Userspace lock contention";

  lt_priority["vt_waitactive"] = 3;
  lt_reason["vt_waitactive"] = "vt_waitactive IOCTL";

  lt_priority["acquire_console_sem"] = 3;
  lt_reason["acquire_console_sem"] = "Waiting for console access";

  lt_priority["filp_close"] = 3;
  lt_reason["filp_close"] = "Closing a file";

  lt_priority["sync_inode"] = 3;
  lt_reason["sync_inode"] = "(f)syncing an inode to disk";

  lt_priority["ata_exec_internal_sg"] = 3;
  lt_reason["ata_exec_internal_sg"] = "Executing internal ATA command";

  lt_priority["writeback_inodes"] = 3;
  lt_reason["writeback_inodes"] = "Writing back inodes";

  lt_priority["ext3_orphan_add "] = 3;
  lt_reason["ext3_orphan_add "] = "EXT3 adding orphan";

  lt_priority["ext3_mark_inode_dirty "] = 3;
  lt_reason["ext3_mark_inode_dirty "] = "EXT3 marking inode dirty";

  lt_priority["ext3_unlink "] = 3;
  lt_reason["ext3_unlink "] = "EXT3 unlinking file";

  lt_priority["ext3_create"] = 3;
  lt_reason["ext3_create"] = "EXT3 Creating a file";

  lt_priority["log_do_checkpoint"] = 3;
  lt_reason["log_do_checkpoint"] = "EXT3 journal checkpoint";

  lt_priority["generic_delete_inode"] = 3;
  lt_reason["generic_delete_inode"] = "Deleting an inode";

  lt_priority["proc_delete_inode"] = 3;
  lt_reason["proc_delete_inode"] = "Removing /proc file";

  lt_priority["do_truncate"] = 3;
  lt_reason["do_truncate"] = "Truncating file";

  lt_priority["sys_execve"] = 3;
  lt_reason["sys_execve"] = "Executing a program";

  lt_priority["journal_commit_transaction"] = 3;
  lt_reason["journal_commit_transaction"] = "EXT3: committing transaction";

  lt_priority["__stop_machine_run"] = 3;
  lt_reason["__stop_machine_run"] = "Freezing the kernel (for module load)";

  lt_priority["sys_munmap"] = 3;
  lt_reason["sys_munmap"] = "unmapping memory";

  lt_priority["sys_mmap"] = 3;
  lt_reason["sys_mmap"] = "mmaping memory";

  lt_priority["sync_buffer"] = 3;
  lt_reason["sync_buffer"] = "Writing buffer to disk (synchronous)";

  lt_priority["inotify_inode_queue_event"] = 3;
  lt_reason["inotify_inode_queue_event"] = "Inotify event";

  lt_priority["proc_lookup"] = 3;
  lt_reason["proc_lookup"] = "Looking up /proc file";

  lt_priority["generic_make_request"] = 3;
  lt_reason["generic_make_request"] = "Creating block layer request";

  lt_priority["get_request_wait"] = 3;
  lt_reason["get_request_wait"] = "Creating block layer request";

  lt_priority["alloc_page_vma"] = 3;
  lt_reason["alloc_page_vma"] = "Allocating a VMA";

  lt_priority["blkdev_direct_IO"] = 3;
  lt_reason["blkdev_direct_IO"] = "Direct block device IO";

  lt_priority["sys_mprotect"] = 3;
  lt_reason["sys_mprotect"] = "mprotect() system call";

  lt_priority["shrink_icache_memory"] = 3;
  lt_reason["shrink_icache_memory"] = "reducing inode cache memory footprint";

  lt_priority["vfs_stat_fd"] = 3;
  lt_reason["vfs_stat_fd"] = "stat() operation";

  lt_priority["cdrom_open"] = 3;
  lt_reason["cdrom_open"] = "opening cdrom device";

  lt_priority["sys_epoll_wait"] = 3;
  lt_reason["sys_epoll_wait"] = "Waiting for event (epoll)";

  lt_priority["sync_sb_inodes"] = 3;
  lt_reason["sync_sb_inodes"] = "Syncing inodes";

  lt_priority["tcp_connect"] = 3;
  lt_reason["tcp_connect"] = "TCP/IP connect";

  lt_priority["ata_scsi_ioctl"] = 3;
  lt_reason["ata_scsi_ioctl"] = "ATA/SCSI disk ioctl";

  lt_priority["kvm_vcpu_ioctl"] = 3;
  lt_reason["kvm_vcpu_ioctl"] = "KVM ioctl";

  lt_priority["do_rmdir"] = 3;
  lt_reason["do_rmdir"] = "Removing directory";

  lt_priority["vfs_rmdir"] = 3;
  lt_reason["vfs_rmdir"] = "Removing directory";

  lt_priority["sys_flock"] = 3;
  lt_reason["sys_flock"] = "flock() on a file";

  lt_priority["usbdev_open"] = 3;
  lt_reason["usbdev_open"] = "opening USB device";

  lt_priority["lock_kernel"] = 3;
  lt_reason["lock_kernel"] = "Big Kernel Lock contention";

  lt_priority["blk_execute_rq"] = 3;
  lt_reason["blk_execute_rq"] = "Submitting block IO";

  lt_priority["scsi_cmd_ioctl"] = 3;
  lt_reason["scsi_cmd_ioctl"] = "SCSI ioctl command";

  lt_priority["acpi_ec_transaction"] = 3;
  lt_reason["acpi_ec_transaction"] = "ACPI hardware access";

  lt_priority["journal_get_undo_access"] = 3;
  lt_reason["journal_get_undo_access"] = "Waiting for EXT3 journal undo operation";

  lt_priority["i915_irq_wait"] = 3;
  lt_reason["i915_irq_wait"] = "Waiting for GPU interrupt";

  lt_priority["i915_gem_throttle_ioctl"] = 3;
  lt_reason["i915_gem_throttle_ioctl"] = "Throttling GPU while waiting for commands";

  lt_priority["do_page_fault"] = 5;
  lt_reason["do_page_fault"] = "Page fault";

  lt_priority["handle_mm_fault"] = 5;
  lt_reason["handle_mm_fault"] = "Page fault";

  lt_priority["filemap_fault"] = 5;
  lt_reason["filemap_fault"] = "Page fault";

  lt_priority["sync_filesystems"] = 5;
  lt_reason["sync_filesystems"] = "Syncing filesystem";

  lt_priority["sys_nanosleep"] = 5;
  lt_reason["sys_nanosleep"] = "Application requested delay";

  lt_priority["sys_pause"] = 5;
  lt_reason["sys_pause"] = "Application requested delay";

  lt_priority["evdev_read"] = 5;
  lt_reason["evdev_read"] = "Reading keyboard/mouse input";

  lt_priority["do_fsync"] = 5;
  lt_reason["do_fsync"] = "fsync() on a file";

  lt_priority["__log_wait_for_space"] = 5;
  lt_reason["__log_wait_for_space"] = "Waiting for EXT3 journal space";

}

/*
 * end latencytap.stp porting.
 */

////////////////////////////////////////////////////////////////////////////////
//////// JS Backtrace Support

////////////////////////////////////////////////////////////////////////////////
//// XPConnect-based

/**
 * Print the current JS stack assuming we are operating in a native context
 *  without an explicit JSContext directly available.
 *
 * Our trace probes (try to) cover all crossings from native space into JS
 *  space because they are (hopefully) rare and usually convey interesting
 *  activity.  We leverage this to push those JSContexts onto a stack so that
 *  this routine can use them to perform a backtrace.
 * An alternate XPConnect-specific way we could roll would be to do what
 *  our VProbes jsstack.emt script did and get XPConnect's thread-local data
 *  to find its current JSContext and use that.
 *
 * When we say print, we literally mean print; we printf our output with the
 *  assumption we are operating in a JSON value context.  We can't just return
 *  a string since the size of the backtrace could be greater than the maximum
 *  allowed string size.
 * If we don't have a JSContext available, we accordingly just output "null".
 */
function dump_jsstack_under_native() {
  ctx = tid();
  depth = t_jscx_depth[ctx];

  if (depth) {
    cx = td_jscx_ptr[ctx, depth - 1];
    if (cx)
      dump_jsstack(cx);
    else
      printf("null");
  }
  else {
    printf("null");
  }
}

////////////////////////////////////////////////////////////////////////////////
//// With a JSContext

/**
 * printf a JSON array representing the current stack state.  Each frame is
 *  represented as an object 
 */
function dump_jsstack(cx) {
  regs = @cast(cx, "JSContext", @@lib:bin/libxul.so)->regs;
  if (regs) {
    fp = @cast(regs, "JSFrameRegs", @@lib:bin/libxul.so)->fp;
  }
  if (!regs || !fp) {
    printf("null");
  }

  if (regs && fp) {
  printf("[");
  first = 1;
  while(fp) {
    flags = @cast(fp, "JSStackFrame", @@lib:bin/libxul.so)->flags_;
    
    if (!first)
      printf(",");

    // JSFRAME_FUNCTION
    if (flags & 0x2) {
      jsfun = @cast(fp, "JSStackFrame", @@lib:bin/libxul.so)->exec->fun;
      printf("{%s}",
             script_info_from_jsfun(jsfun));
    }
    // JSFRAME_GLOBAL
    else if (flags & 0x1) {
      script = @cast(fp, "JSStackFrame", @@lib:bin/libxul.so)->exec->script;
      printf("{%s,\"functionName\":\"<global>\"}",
             script_info_from_jsscript(script));
    }
    // DOES NOT FEMPUTE!
    else {
      printf("{\"flags\":%d}", flags);
    }

    fp = @cast(fp, "JSStackFrame", @@lib:bin/libxul.so)->prev_;
    first = 0;
  }
  printf("]");
  }
}

////////////////////////////////////////////////////////////////////////////////
//////// Common JS extraction stuff

global jsfun_cache_func_name;
global jsfun_cache_filename;
global jsfun_cache_line;

function jsobj_class_name(jsobj) {
  return user_string(@cast(jsobj, "JSObject", @@lib:bin/libxul.so)->clasp->name);
}

function jsstr_to_string(jsstr) {
  if (!jsstr)
    return "<void>";
  if (jsstr == 0xa5a5a5a5a5a5a5a5 ||
      jsstr == 0x25a5a5a5a5a5)
    return "<freed read bad>";

  // the flag bits are the lower order bits; shift FLAGS_LENGTH_SHIFT.
  lenAndFlags = @cast(jsstr, "JSString", @@lib:bin/libxul.so)->mLengthAndFlags;
  if (lenAndFlags & 0xf) {
    if (lenAndFlags & 0x3 == 0) {
      if (lenAndFlags & 0x4 == 0x4)
        return "<atomized>";
      else if (lenAndFlags & 0x8 == 0x8)
        return "<mutable>";
    }
    else if (lenAndFlags & 0x3 == 1)
      return "<dependent>";
    else if (lenAndFlags & 0x3 == 2)
      return "<interior node>";
    else if (lenAndFlags & 0x3 == 3)
      return "<top node>";
  }
  len = lenAndFlags >> 4;
  if (!len)
    return "";

  cp = @cast(jsstr, "JSString", @@lib:bin/libxul.so)->mChars;
  return user_u16_string(cp, len);
}

function jsval_to_string(jsval) {
  tag = (jsval >> 47) & 0xf;
  if (jsval == 0) {
    return "null";
  }
  // double
  else if (tag == 0x0) {
    //return sprintf("%f", jsval);
    return "<double>";
  }
  // integer!
  else if (tag == 0x1) {
    return sprintf("%d", jsval & 0xffffffff)
  }
  // undefined
  else if (tag == 0x2) {
    return "undefined";
  }
  // boolean
  else if (tag == 0x3) {
    if (jsval & 0xffffffff)
      return "true";
    else
      return "false";
  }
  // magic
  else if (tag == 0x4) {
    return "<magic>";
  }
  // string
  else if (tag == 0x5) {
    // mask off the magic double-boxing wrapped
    return jsstr_to_string(jsval & 0x00007FFFFFFFFFFF);
  }
  // null
  else if (tag == 0x6) {
    return "null";
  }
  else if (tag == 0x7) {
    objptr = jsval & 0x00007FFFFFFFFFFF;
    return sprintf("<jsobj %s %p>", jsobj_class_name(objptr), objptr);
  }
  return sprintf("<??? %p>", jsval);
}

// jsfunval is a jsval which is a pointer to the JSFunction...
/*
function script_info_from_jsfunval(jsfunval) {
  if (jsfunval) {
    jsfun = @cast(jsfunval, "js::", @@lib:bin/libxul.so)->fslots[0]->data->asPtr;
  }
  else {
    jsfun = 0;
  }
  return script_info_from_jsfun(jsfun);
}
*/

/**
 * We are given an object of class type JSFunction where the private slot holds
 *  the actual JSFunction instance.
 */
function script_info_from_jsfunobj(jsfunobj) {
  // it is not nunboxed; it is a directly usable pointer!
  return script_info_from_jsfun(
    @cast(jsfunobj, "JSObject", @@lib:bin/libxul.so)->fslots[0]->data->asPtr);
}

/**
 * Given an actual JSFunction, get the script/line/function name and format them
 *  as a JSON object substring.
 */
function script_info_from_jsfun(jsfun) {
  if (jsfun_cache_line[jsfun] == 0) {
    if (!jsfun) {
      atom = 0;
      jsfun_cache_func_name[jsfun] = "<no func>";
    }
    else {
      atom = @cast(jsfun, "JSFunction", @@lib:bin/libxul.so)->atom;
    }

    // both JSFunction and JSObject define a 'flags' field; systemtap appears
    //  to favor JSObject's, so we try and outwit it by getting the address of
    //  nargs which immediately precedes the field, add 2, and read the short
    funflags = user_short(
                 &@cast(jsfun, "JSFunction", @@lib:bin/libxul.so)->nargs +
                 2);

    // interpreted?
    if ((funflags & 0xc000) >= 0x4000) {
      jsfun_cache_func_name[jsfun] = jsstr_to_string(atom);

      script = @cast(jsfun, "JSFunction", @@lib:bin/libxul.so)->u->i->script;
      if (script) {
        jsfun_cache_filename[jsfun] =
          basename(user_string(@cast(script, "JSScript",
                                     @@lib:bin/libxul.so)->filename));
        jsfun_cache_line[jsfun] = @cast(script, "JSScript",
                                        @@lib:bin/libxul.so)->lineno;
      }
      else {
        jsfun_cache_filename[jsfun] = "<no script>";
        jsfun_cache_line[jsfun] = 1;
      }
    }
// XXX this is a systemtap dwarf probabilistic nightmare; disable.
/*
    else if (funflags & 0x2000) {
      jsfun_cache_filename[jsfun] = "<trace>";
      jsfun_cache_func_name[jsfun] = atom ? jsstr_to_string(atom) :
        sprintf(":!vt:%x",
                @cast(jsfun, "JSFunction",
                      @@lib:bin/libxul.so)->u->n->trcinfo->native);
        
      jsfun_cache_line[jsfun] = 1;
    }
*/
    else { // native
      // XXX emit pointer with translation decorations.
      jsfun_cache_filename[jsfun] = "<native>";
      jsfun_cache_func_name[jsfun] = atom ? jsstr_to_string(atom) :
        sprintf(":!vt:%x",
                @cast(jsfun, "JSFunction", @@lib:bin/libxul.so)->u->n->native);
      jsfun_cache_line[jsfun] = funflags;
    }
  }
  return sprintf("\"scriptName\":\"%s\",\"scriptLine\":%d,\"functionName\":\"%s\"",
                 jsfun_cache_filename[jsfun],
                 jsfun_cache_line[jsfun],
                 jsfun_cache_func_name[jsfun]);
}

function script_info_from_jsscript(script) {
  // We expect calls to ourself to be rare and have different values each time,
  //  so no caching.
  return sprintf("\"scriptName\":\"%s\",\"scriptLine\":%d",
                 basename(user_string(@cast(script, "JSScript",
                                            @@lib:bin/libxul.so)->filename)),
                 @cast(script, "JSScript",
                       @@lib:bin/libxul.so)->lineno);
}


/**
 * Copy a u16 string truncating to ASCII and escaping single quote chars
 */
function user_u16_string:string (addr: long, nchars: long) %{ /* pure */ /* unprivileged */
  // we need space for the u16...
  // because we escape various characters, we need to lower the max by one
  //  character to make sure we have space for our nul terminator.
  int64_t len = clamp_t(int64_t, THIS->nchars*2, 2, MAXSTRINGLEN - 2);
  if (len%2)
    len--;
  assert_is_myproc();
  if (_stp_copy_from_user(THIS->__retvalue,
                          (char __user *) (uintptr_t) THIS->addr,
                          len) == 0) {
    // now transform down...
    char *ocp = THIS->__retvalue;
    uint16_t *icp = (uint16_t *)THIS->__retvalue;
    uint16_t *termp = (uint16_t *)&THIS->__retvalue[len];
    for (;icp < termp; icp++) {
      if (*icp >= 0x80)
        *ocp++ = 'X';
      else {
        char c = (char)*icp;
        if (c == '"') {
          *ocp++ = '\\';
          *ocp++ = '"';
        }
        else if (c == '\n') {
          *ocp++ = '\\';
          *ocp++ = 'n';
        }
        // convert tabs to single spaces. tabs are stupid and escaping them
        //  legally takes too much space.
        else if (c == '\t') {
          *ocp++ = ' ';
        }
        else {
          *ocp++ = c;
        }
      }
    }
    *ocp = '\0';
  }
  else {
    strlcpy(THIS->__retvalue, "<problem>", MAXSTRINGLEN);
  }
%}

function basename:string (str: string) %{ /* pure */ /* unprivileged */
  char *cp;
  char *last_slash = THIS->str;
  for (cp = THIS->str; *cp != '\0'; cp++) {
    if (*cp == '/')
      last_slash = cp+1;
  }

  strlcpy(THIS->__retvalue, last_slash, strlen(last_slash) + 1);
%}
